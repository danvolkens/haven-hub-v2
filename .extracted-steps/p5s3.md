## Step 5.3: Implement Pinterest OAuth Flow

- **Task**: Create the complete Pinterest OAuth flow with board sync.

- **Files**:

### `lib/integrations/pinterest/config.ts`
```typescript
export const PINTEREST_CONFIG = {
  clientId: process.env.PINTEREST_CLIENT_ID!,
  clientSecret: process.env.PINTEREST_CLIENT_SECRET!,
  scopes: [
    'boards:read',
    'boards:write',
    'pins:read',
    'pins:write',
    'user_accounts:read',
    'ads:read',
    'ads:write',
  ],
  apiVersion: 'v5',
};

export function getPinterestAuthUrl(state: string, redirectUri: string): string {
  const params = new URLSearchParams({
    client_id: PINTEREST_CONFIG.clientId,
    redirect_uri: redirectUri,
    response_type: 'code',
    scope: PINTEREST_CONFIG.scopes.join(','),
    state,
  });

  return `https://www.pinterest.com/oauth/?${params.toString()}`;
}

export function getPinterestApiUrl(): string {
  return `https://api.pinterest.com/${PINTEREST_CONFIG.apiVersion}`;
}
```

### `lib/integrations/pinterest/client.ts`
```typescript
import { getPinterestApiUrl } from './config';

interface PinterestClientOptions {
  accessToken: string;
}

export class PinterestClient {
  private accessToken: string;
  private baseUrl: string;

  constructor({ accessToken }: PinterestClientOptions) {
    this.accessToken = accessToken;
    this.baseUrl = getPinterestApiUrl();
  }

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${this.baseUrl}${endpoint}`;

    const response = await fetch(url, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${this.accessToken}`,
        ...options.headers,
      },
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.message || `Pinterest API error: ${response.status}`);
    }

    return response.json();
  }

  // User account
  async getUserAccount(): Promise<PinterestUser> {
    return this.request('/user_account');
  }

  // Boards
  async getBoards(params?: { page_size?: number; bookmark?: string }): Promise<PinterestPagedResponse<PinterestBoard>> {
    const query = new URLSearchParams(params as Record<string, string>);
    return this.request(`/boards?${query}`);
  }

  async createBoard(board: CreateBoardRequest): Promise<PinterestBoard> {
    return this.request('/boards', {
      method: 'POST',
      body: JSON.stringify(board),
    });
  }

  // Pins
  async createPin(pin: CreatePinRequest): Promise<PinterestPin> {
    return this.request('/pins', {
      method: 'POST',
      body: JSON.stringify(pin),
    });
  }

  async getPin(pinId: string): Promise<PinterestPin> {
    return this.request(`/pins/${pinId}`);
  }

  async deletePin(pinId: string): Promise<void> {
    await this.request(`/pins/${pinId}`, { method: 'DELETE' });
  }

  // Analytics
  async getPinAnalytics(
    pinId: string,
    params: {
      start_date: string;
      end_date: string;
      metric_types: string[];
    }
  ): Promise<PinterestPinAnalytics> {
    const query = new URLSearchParams({
      start_date: params.start_date,
      end_date: params.end_date,
      metric_types: params.metric_types.join(','),
    });
    return this.request(`/pins/${pinId}/analytics?${query}`);
  }

  async getUserAccountAnalytics(params: {
    start_date: string;
    end_date: string;
    metric_types: string[];
  }): Promise<PinterestAccountAnalytics> {
    const query = new URLSearchParams({
      start_date: params.start_date,
      end_date: params.end_date,
      metric_types: params.metric_types.join(','),
    });
    return this.request(`/user_account/analytics?${query}`);
  }

  // Ads
  async getAdAccounts(): Promise<PinterestPagedResponse<PinterestAdAccount>> {
    return this.request('/ad_accounts');
  }

  async createAdCampaign(
    adAccountId: string,
    campaign: CreateCampaignRequest
  ): Promise<PinterestCampaign> {
    return this.request(`/ad_accounts/${adAccountId}/campaigns`, {
      method: 'POST',
      body: JSON.stringify(campaign),
    });
  }
}

// Types
export interface PinterestUser {
  account_type: string;
  profile_image: string;
  website_url: string;
  username: string;
  business_name: string;
}

export interface PinterestBoard {
  id: string;
  name: string;
  description: string;
  privacy: 'PUBLIC' | 'PROTECTED' | 'SECRET';
  pin_count: number;
  follower_count: number;
}

export interface PinterestPin {
  id: string;
  created_at: string;
  link: string;
  title: string;
  description: string;
  board_id: string;
  media: {
    media_type: 'image' | 'video';
    source: {
      source_type: string;
      url: string;
    };
  };
}

export interface CreateBoardRequest {
  name: string;
  description?: string;
  privacy?: 'PUBLIC' | 'PROTECTED' | 'SECRET';
}

export interface CreatePinRequest {
  board_id: string;
  media_source: {
    source_type: 'image_url';
    url: string;
  };
  title?: string;
  description?: string;
  link?: string;
  alt_text?: string;
}

export interface PinterestPinAnalytics {
  all_time: {
    impressions: number;
    saves: number;
    clicks: number;
  };
  daily_metrics: Array<{
    date: string;
    data_status: string;
    metrics: {
      IMPRESSION: number;
      SAVE: number;
      PIN_CLICK: number;
      OUTBOUND_CLICK: number;
    };
  }>;
}

export interface PinterestAccountAnalytics {
  all_time: {
    impressions: number;
    engagements: number;
  };
}

export interface PinterestAdAccount {
  id: string;
  name: string;
  currency: string;
  status: string;
}

export interface PinterestCampaign {
  id: string;
  name: string;
  status: string;
  lifetime_spend_cap: number;
  daily_spend_cap: number;
}

export interface CreateCampaignRequest {
  name: string;
  status: 'ACTIVE' | 'PAUSED';
  lifetime_spend_cap?: number;
  daily_spend_cap?: number;
  objective_type: 'AWARENESS' | 'CONSIDERATION' | 'CONVERSIONS';
}

export interface PinterestPagedResponse<T> {
  items: T[];
  bookmark?: string;
}
```

### `app/api/integrations/pinterest/callback/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { getAdminClient } from '@/lib/supabase/admin';
import { getUserId } from '@/lib/auth/session';
import { PINTEREST_CONFIG } from '@/lib/integrations/pinterest/config';
import { PinterestClient } from '@/lib/integrations/pinterest/client';

export async function GET(request: NextRequest) {
  try {
    const userId = await getUserId();
    const searchParams = request.nextUrl.searchParams;
    
    const code = searchParams.get('code');
    const state = searchParams.get('state');

    if (!code || !state) {
      throw new Error('Missing required parameters');
    }

    // Verify state
    const supabase = createServerSupabaseClient();
    const { data: integration } = await supabase
      .from('integrations')
      .select('metadata')
      .eq('user_id', userId)
      .eq('provider', 'pinterest')
      .single();

    if (!integration || integration.metadata.oauth_state !== state) {
      throw new Error('Invalid state parameter');
    }

    // Exchange code for tokens
    const redirectUri = `${process.env.NEXT_PUBLIC_APP_URL}/api/integrations/pinterest/callback`;
    
    const tokenResponse = await fetch('https://api.pinterest.com/v5/oauth/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        Authorization: `Basic ${Buffer.from(
          `${PINTEREST_CONFIG.clientId}:${PINTEREST_CONFIG.clientSecret}`
        ).toString('base64')}`,
      },
      body: new URLSearchParams({
        grant_type: 'authorization_code',
        code,
        redirect_uri: redirectUri,
      }),
    });

    if (!tokenResponse.ok) {
      throw new Error('Failed to exchange code for token');
    }

    const { access_token, refresh_token, expires_in } = await tokenResponse.json();

    // Get user account info
    const client = new PinterestClient({ accessToken: access_token });
    const user = await client.getUserAccount();
    const { items: boards } = await client.getBoards({ page_size: 100 });

    // Store tokens securely
    const adminClient = getAdminClient();
    await adminClient.rpc('store_credential', {
      p_user_id: userId,
      p_provider: 'pinterest',
      p_credential_type: 'access_token',
      p_credential_value: access_token,
    });
    await adminClient.rpc('store_credential', {
      p_user_id: userId,
      p_provider: 'pinterest',
      p_credential_type: 'refresh_token',
      p_credential_value: refresh_token,
    });

    // Calculate token expiration
    const tokenExpiresAt = new Date(Date.now() + expires_in * 1000).toISOString();

    // Update integration record
    await supabase
      .from('integrations')
      .update({
        status: 'connected',
        metadata: {
          account_name: user.business_name || user.username,
          account_id: user.username,
          board_count: boards.length,
        },
        token_expires_at: tokenExpiresAt,
        connected_at: new Date().toISOString(),
        last_error: null,
        last_error_at: null,
      })
      .eq('user_id', userId)
      .eq('provider', 'pinterest');

    // Sync boards to local database
    await syncPinterestBoards(userId, boards);

    // Update setup progress
    await supabase
      .from('user_settings')
      .update({
        setup_progress: supabase.sql`jsonb_set(setup_progress, '{pinterest}', '"completed"')`,
      })
      .eq('user_id', userId);

    // Log activity
    await supabase.rpc('log_activity', {
      p_user_id: userId,
      p_action_type: 'integration_connected',
      p_details: { provider: 'pinterest', accountName: user.username },
      p_executed: true,
      p_module: 'settings',
    });

    return NextResponse.redirect(
      `${process.env.NEXT_PUBLIC_APP_URL}/dashboard/settings/integrations?success=pinterest_connected`
    );
  } catch (error) {
    console.error('Pinterest callback error:', error);
    return NextResponse.redirect(
      `${process.env.NEXT_PUBLIC_APP_URL}/dashboard/settings/integrations?error=pinterest_callback_failed`
    );
  }
}

async function syncPinterestBoards(userId: string, boards: Array<{ id: string; name: string; pin_count: number }>) {
  const supabase = createServerSupabaseClient();

  // Upsert boards
  for (const board of boards) {
    await supabase.from('pinterest_boards').upsert({
      user_id: userId,
      pinterest_board_id: board.id,
      name: board.name,
      pin_count: board.pin_count,
      synced_at: new Date().toISOString(),
    });
  }
}
```

- **Step Dependencies**: Step 5.2
- **User Instructions**: 
  1. Create Pinterest Developer account and app
  2. Add PINTEREST_CLIENT_ID and PINTEREST_CLIENT_SECRET to .env.local
  3. Set OAuth redirect URL in Pinterest Developer Dashboard

---

