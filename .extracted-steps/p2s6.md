## Step 2.3: Set Up Upstash Redis Client

- **Task**: Configure Upstash Redis client for caching layer with helper functions and rate limiting.

- **Files**:

### `lib/cache/redis.ts`
```typescript
import { Redis } from '@upstash/redis';

// Ensure environment variables are set
if (!process.env.UPSTASH_REDIS_REST_URL || !process.env.UPSTASH_REDIS_REST_TOKEN) {
  console.warn('Upstash Redis credentials not configured. Caching will be disabled.');
}

// Create Redis client (will throw if credentials missing in production)
export const redis = process.env.UPSTASH_REDIS_REST_URL
  ? new Redis({
      url: process.env.UPSTASH_REDIS_REST_URL,
      token: process.env.UPSTASH_REDIS_REST_TOKEN!,
    })
  : null;

export default redis;

// Check if Redis is available
export function isRedisAvailable(): boolean {
  return redis !== null;
}
```

### `lib/cache/cache-utils.ts`
```typescript
import redis from './redis';

// TTL constants in seconds
export const TTL = {
  VERY_SHORT: 30,      // 30 seconds
  SHORT: 60,           // 1 minute
  MEDIUM: 300,         // 5 minutes
  LONG: 3600,          // 1 hour
  VERY_LONG: 86400,    // 24 hours
  
  // Feature-specific TTLs
  USER_SETTINGS: 60,   // 1 minute (frequently accessed, may change)
  DESIGN_RULES: 3600,  // 1 hour (rarely changes)
  BOARDS: 300,         // 5 minutes (synced periodically)
  INTEGRATION_STATUS: 60, // 1 minute
  APPROVAL_COUNTS: 30, // 30 seconds (real-time-ish)
} as const;

// Cache key prefixes for organization
export const CACHE_PREFIX = {
  USER_SETTINGS: 'user_settings',
  DESIGN_RULES: 'design_rules',
  BOARDS: 'boards',
  APPROVAL_COUNTS: 'approval_counts',
  PIN_SCHEDULE: 'pin_schedule',
  RATE_LIMIT: 'rate_limit',
  INTEGRATION: 'integration',
  DAILY_METRICS: 'daily_metrics',
} as const;

/**
 * Build a cache key from prefix and parts
 */
export function cacheKey(prefix: string, ...parts: (string | number)[]): string {
  return [prefix, ...parts].join(':');
}

/**
 * Get a value from cache, or fetch and cache it if not present
 */
export async function getOrSet<T>(
  key: string,
  fetcher: () => Promise<T>,
  ttlSeconds: number = TTL.MEDIUM
): Promise<T> {
  if (!redis) {
    // Redis not available, just fetch
    return fetcher();
  }

  try {
    // Try to get from cache
    const cached = await redis.get<T>(key);
    if (cached !== null) {
      return cached;
    }

    // Fetch fresh data
    const value = await fetcher();

    // Cache it (don't await to avoid blocking)
    redis.setex(key, ttlSeconds, value).catch((err) => {
      console.error(`Failed to cache key ${key}:`, err);
    });

    return value;
  } catch (error) {
    console.error(`Cache error for key ${key}:`, error);
    // Fall back to fetcher on cache error
    return fetcher();
  }
}

/**
 * Get a value from cache
 */
export async function get<T>(key: string): Promise<T | null> {
  if (!redis) return null;

  try {
    return await redis.get<T>(key);
  } catch (error) {
    console.error(`Cache get error for key ${key}:`, error);
    return null;
  }
}

/**
 * Set a value in cache
 */
export async function set<T>(
  key: string,
  value: T,
  ttlSeconds: number = TTL.MEDIUM
): Promise<void> {
  if (!redis) return;

  try {
    await redis.setex(key, ttlSeconds, value);
  } catch (error) {
    console.error(`Cache set error for key ${key}:`, error);
  }
}

/**
 * Delete a key from cache
 */
export async function invalidate(key: string): Promise<void> {
  if (!redis) return;

  try {
    await redis.del(key);
  } catch (error) {
    console.error(`Cache invalidate error for key ${key}:`, error);
  }
}

/**
 * Delete all keys matching a pattern
 */
export async function invalidatePattern(pattern: string): Promise<number> {
  if (!redis) return 0;

  try {
    const keys = await redis.keys(pattern);
    if (keys.length > 0) {
      await redis.del(...keys);
    }
    return keys.length;
  } catch (error) {
    console.error(`Cache invalidate pattern error for ${pattern}:`, error);
    return 0;
  }
}

/**
 * Invalidate all cache keys for a user
 */
export async function invalidateUserCache(userId: string): Promise<void> {
  await invalidatePattern(`*:${userId}:*`);
  await invalidatePattern(`*:${userId}`);
}

/**
 * Increment a counter (useful for rate limiting, usage tracking)
 */
export async function increment(
  key: string,
  ttlSeconds?: number
): Promise<number> {
  if (!redis) return 0;

  try {
    const newValue = await redis.incr(key);
    if (ttlSeconds && newValue === 1) {
      // Set expiry only on first increment
      await redis.expire(key, ttlSeconds);
    }
    return newValue;
  } catch (error) {
    console.error(`Cache increment error for key ${key}:`, error);
    return 0;
  }
}

/**
 * Get current counter value
 */
export async function getCounter(key: string): Promise<number> {
  if (!redis) return 0;

  try {
    const value = await redis.get<number>(key);
    return value ?? 0;
  } catch (error) {
    console.error(`Cache getCounter error for key ${key}:`, error);
    return 0;
  }
}
```

### `lib/cache/rate-limiter.ts`
```typescript
import { Ratelimit } from '@upstash/ratelimit';
import redis from './redis';

// Only create rate limiters if Redis is available
const createRateLimiter = (
  config: { requests: number; window: `${number} ${'s' | 'm' | 'h' | 'd'}` },
  prefix: string
) => {
  if (!redis) return null;
  
  return new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(config.requests, config.window),
    analytics: true,
    prefix: `ratelimit:${prefix}`,
  });
};

// API rate limiters
export const apiLimiter = createRateLimiter(
  { requests: 100, window: '1 m' },
  'api'
);

// Public endpoint rate limiters (more restrictive)
export const publicApiLimiter = createRateLimiter(
  { requests: 30, window: '1 m' },
  'public'
);

// Quiz submission rate limiter
export const quizLimiter = createRateLimiter(
  { requests: 10, window: '1 m' },
  'quiz'
);

// Webhook rate limiter (higher limit for incoming webhooks)
export const webhookLimiter = createRateLimiter(
  { requests: 1000, window: '1 m' },
  'webhook'
);

// Export rate limiter
export const exportLimiter = createRateLimiter(
  { requests: 5, window: '1 h' },
  'export'
);

// Pinterest API rate limiter (per spec: 100 requests/min for pins)
export const pinterestLimiter = createRateLimiter(
  { requests: 90, window: '1 m' }, // Leave 10% buffer
  'pinterest'
);

/**
 * Check rate limit and return result
 */
export async function checkRateLimit(
  limiter: Ratelimit | null,
  identifier: string
): Promise<{
  success: boolean;
  limit: number;
  remaining: number;
  reset: number;
}> {
  if (!limiter) {
    // No rate limiting if Redis unavailable
    return { success: true, limit: 0, remaining: 0, reset: 0 };
  }

  const result = await limiter.limit(identifier);
  
  return {
    success: result.success,
    limit: result.limit,
    remaining: result.remaining,
    reset: result.reset,
  };
}

/**
 * Rate limit middleware helper for API routes
 */
export async function rateLimit(
  limiter: Ratelimit | null,
  identifier: string
): Promise<Response | null> {
  const result = await checkRateLimit(limiter, identifier);
  
  if (!result.success) {
    return new Response(
      JSON.stringify({
        error: 'Too many requests',
        retryAfter: Math.ceil((result.reset - Date.now()) / 1000),
      }),
      {
        status: 429,
        headers: {
          'Content-Type': 'application/json',
          'X-RateLimit-Limit': String(result.limit),
          'X-RateLimit-Remaining': String(result.remaining),
          'X-RateLimit-Reset': String(result.reset),
          'Retry-After': String(Math.ceil((result.reset - Date.now()) / 1000)),
        },
      }
    );
  }
  
  return null; // No rate limit hit
}
```

- **Step Dependencies**: Step 1.1
- **User Instructions**: 
  1. Create an Upstash Redis database at console.upstash.com
  2. Copy the REST URL and Token to `.env.local`

---

*[Continuing with Steps 2.4-2.6 and Phases 3-4 in the same document...]*

Due to length, I'll continue in the next part. This Part 2 covers:
- Steps 1.8-1.10: Supabase setup, Authentication (full code), Dashboard layout
- Steps 2.1-2.3: User settings migration, Activity log migration, Redis cache

**Next: Part 3 will continue with Steps 2.4-2.6 (R2 Storage, Trigger.dev, Cron), Phase 3 (Operator Mode), and Phase 4 (Approval Queue)**
