## Step 15.2: Implement Quiz Service and API

- **Task**: Create the quiz scoring service and API endpoints.

- **Files**:

### `lib/quiz/quiz-service.ts`
```typescript
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { syncLeadToKlaviyo } from '@/lib/integrations/klaviyo/lead-sync';
import type { Quiz, QuizResponse, QuizResult, SubmitQuizRequest, CollectionScores } from '@/types/quiz';

interface QuizSubmitResult {
  success: boolean;
  response?: QuizResponse;
  result?: QuizResult;
  error?: string;
}

export async function submitQuiz(
  request: SubmitQuizRequest,
  metadata?: {
    ipAddress?: string;
    userAgent?: string;
  }
): Promise<QuizSubmitResult> {
  const supabase = createServerSupabaseClient();

  try {
    // Get quiz
    const { data: quiz } = await supabase
      .from('quizzes')
      .select('*, questions:quiz_questions(*, answers:quiz_answers(*))')
      .eq('id', request.quizId)
      .eq('status', 'active')
      .single();

    if (!quiz) {
      return { success: false, error: 'Quiz not found' };
    }

    // Calculate result
    const { data: calcResult } = await supabase.rpc('calculate_quiz_result', {
      p_quiz_id: request.quizId,
      p_answers: request.answers,
    });

    if (!calcResult || calcResult.length === 0) {
      return { success: false, error: 'Failed to calculate result' };
    }

    const { result_collection, scores } = calcResult[0];

    // Create or update lead if email provided
    let leadId: string | null = null;

    if (request.email) {
      const { data: lead, error: leadError } = await supabase
        .from('leads')
        .upsert({
          user_id: quiz.user_id,
          email: request.email,
          first_name: request.firstName,
          source: 'quiz',
          quiz_id: quiz.id,
          quiz_results: {
            answers: request.answers,
            scores,
            recommendation: result_collection,
          },
          recommended_collection: result_collection,
        }, {
          onConflict: 'user_id,email',
        })
        .select()
        .single();

      if (lead) {
        leadId = lead.id;

        // Sync to Klaviyo with quiz segment
        const resultDef = await supabase
          .from('quiz_results')
          .select('klaviyo_segment_id')
          .eq('quiz_id', quiz.id)
          .eq('collection', result_collection)
          .single();

        if (resultDef.data?.klaviyo_segment_id) {
          await syncLeadToKlaviyo(quiz.user_id, lead, {
            listId: resultDef.data.klaviyo_segment_id,
            tags: [`quiz-${result_collection}`, `quiz-${quiz.slug}`],
          });
        }
      }
    }

    // Create quiz response
    const { data: response, error: responseError } = await supabase
      .from('quiz_responses')
      .insert({
        quiz_id: request.quizId,
        user_id: quiz.user_id,
        lead_id: leadId,
        answers: request.answers,
        scores,
        result_collection,
        completed_at: new Date().toISOString(),
        ip_address: metadata?.ipAddress,
        user_agent: metadata?.userAgent,
      })
      .select()
      .single();

    if (responseError) {
      throw new Error(responseError.message);
    }

    // Update quiz completion count
    await supabase
      .from('quizzes')
      .update({ completions: quiz.completions + 1 })
      .eq('id', quiz.id);

    // Get result definition
    const { data: result } = await supabase
      .from('quiz_results')
      .select('*')
      .eq('quiz_id', quiz.id)
      .eq('collection', result_collection)
      .single();

    // Log activity
    await supabase.rpc('log_activity', {
      p_user_id: quiz.user_id,
      p_action_type: 'quiz_completed',
      p_details: {
        quizId: quiz.id,
        responseId: response.id,
        result: result_collection,
        leadId,
      },
      p_executed: true,
      p_module: 'quiz',
      p_reference_id: response.id,
      p_reference_table: 'quiz_responses',
    });

    return {
      success: true,
      response: response as QuizResponse,
      result: result as QuizResult,
    };
  } catch (error) {
    console.error('Quiz submission error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

export async function getQuizAnalytics(
  userId: string,
  quizId: string
): Promise<{
  totalResponses: number;
  collectionBreakdown: Record<string, number>;
  averageTimeSeconds: number;
  conversionRate: number;
}> {
  const supabase = createServerSupabaseClient();

  const { data: responses } = await supabase
    .from('quiz_responses')
    .select('result_collection, time_spent_seconds, lead_id')
    .eq('quiz_id', quizId)
    .eq('user_id', userId);

  if (!responses || responses.length === 0) {
    return {
      totalResponses: 0,
      collectionBreakdown: { grounding: 0, wholeness: 0, growth: 0 },
      averageTimeSeconds: 0,
      conversionRate: 0,
    };
  }

  const collectionBreakdown = {
    grounding: responses.filter((r) => r.result_collection === 'grounding').length,
    wholeness: responses.filter((r) => r.result_collection === 'wholeness').length,
    growth: responses.filter((r) => r.result_collection === 'growth').length,
  };

  const times = responses
    .filter((r) => r.time_spent_seconds !== null)
    .map((r) => r.time_spent_seconds as number);

  const averageTimeSeconds = times.length > 0
    ? times.reduce((a, b) => a + b, 0) / times.length
    : 0;

  const withLead = responses.filter((r) => r.lead_id !== null).length;
  const conversionRate = responses.length > 0 ? withLead / responses.length : 0;

  return {
    totalResponses: responses.length,
    collectionBreakdown,
    averageTimeSeconds,
    conversionRate,
  };
}
```

### `app/api/quiz/[slug]/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

// Public endpoint - no auth required
export async function GET(
  request: NextRequest,
  { params }: { params: { slug: string } }
) {
  try {
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    );
    
    const { data: quiz, error } = await supabase
      .from('quizzes')
      .select(`
        id,
        title,
        description,
        slug,
        show_results_immediately,
        require_email,
        questions:quiz_questions(
          id,
          question_text,
          question_type,
          position,
          image_url,
          help_text,
          is_required,
          answers:quiz_answers(
            id,
            answer_text,
            position,
            image_url
          )
        )
      `)
      .eq('slug', params.slug)
      .eq('status', 'active')
      .single();
    
    if (error || !quiz) {
      return NextResponse.json({ error: 'Quiz not found' }, { status: 404 });
    }
    
    // Sort questions and answers by position
    quiz.questions.sort((a: any, b: any) => a.position - b.position);
    quiz.questions.forEach((q: any) => {
      q.answers.sort((a: any, b: any) => a.position - b.position);
    });
    
    // Track quiz start
    await supabase
      .from('quizzes')
      .update({ starts: supabase.sql`starts + 1` })
      .eq('id', quiz.id);
    
    return NextResponse.json({ quiz });
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to load quiz' },
      { status: 500 }
    );
  }
}
```

### `app/api/quiz/[slug]/submit/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { submitQuiz } from '@/lib/quiz/quiz-service';
import { createClient } from '@supabase/supabase-js';

const submitSchema = z.object({
  answers: z.record(z.array(z.string())),
  email: z.string().email().optional(),
  firstName: z.string().optional(),
});

// Public endpoint
export async function POST(
  request: NextRequest,
  { params }: { params: { slug: string } }
) {
  try {
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    );
    
    // Get quiz ID from slug
    const { data: quiz } = await supabase
      .from('quizzes')
      .select('id, require_email')
      .eq('slug', params.slug)
      .eq('status', 'active')
      .single();
    
    if (!quiz) {
      return NextResponse.json({ error: 'Quiz not found' }, { status: 404 });
    }
    
    const body = await request.json();
    const data = submitSchema.parse(body);
    
    // Validate email if required
    if (quiz.require_email && !data.email) {
      return NextResponse.json(
        { error: 'Email is required' },
        { status: 400 }
      );
    }
    
    const result = await submitQuiz(
      {
        quizId: quiz.id,
        answers: data.answers,
        email: data.email,
        firstName: data.firstName,
      },
      {
        ipAddress: request.headers.get('x-forwarded-for') || undefined,
        userAgent: request.headers.get('user-agent') || undefined,
      }
    );
    
    if (!result.success) {
      return NextResponse.json({ error: result.error }, { status: 400 });
    }
    
    return NextResponse.json({
      success: true,
      result: result.result,
      scores: result.response?.scores,
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: 'Invalid request body' }, { status: 400 });
    }
    return NextResponse.json(
      { error: 'Failed to submit quiz' },
      { status: 500 }
    );
  }
}
```

- **Step Dependencies**: Step 15.1
- **User Instructions**: None

---

# Phase 16: Cart Abandonment

