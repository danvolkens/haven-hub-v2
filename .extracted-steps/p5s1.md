## Step 5.1: Create Integration Credentials Schema

- **Task**: Create database schema for storing OAuth tokens and API keys securely using Supabase Vault.

- **Files**:

### `supabase/migrations/004_integrations.sql`
```sql
-- ============================================================================
-- Migration: 004_integrations
-- Description: Integration credentials and connection status
-- Feature: 3 (Setup Wizard), Integrations
-- ============================================================================

-- ============================================================================
-- Integrations Table (public metadata, tokens in vault)
-- ============================================================================
CREATE TABLE integrations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  
  -- Integration type
  provider TEXT NOT NULL CHECK (provider IN (
    'shopify', 'pinterest', 'klaviyo', 'dynamic_mockups', 'resend', 'sky_pilot'
  )),
  
  -- Connection status
  status TEXT NOT NULL DEFAULT 'disconnected' CHECK (status IN (
    'disconnected', 'connecting', 'connected', 'error', 'expired'
  )),
  
  -- Public metadata (no secrets)
  metadata JSONB NOT NULL DEFAULT '{}',
  -- For Shopify: { shop_domain, shop_name }
  -- For Pinterest: { account_name, board_count }
  -- For Klaviyo: { list_count }
  -- For Dynamic Mockups: { credits_remaining }
  
  -- Error tracking
  last_error TEXT,
  last_error_at TIMESTAMPTZ,
  
  -- Token refresh tracking
  token_expires_at TIMESTAMPTZ,
  last_refreshed_at TIMESTAMPTZ,
  
  -- Connection timestamps
  connected_at TIMESTAMPTZ,
  disconnected_at TIMESTAMPTZ,
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  UNIQUE(user_id, provider)
);

-- ============================================================================
-- Indexes
-- ============================================================================
CREATE INDEX idx_integrations_user ON integrations(user_id);
CREATE INDEX idx_integrations_status ON integrations(user_id, status);
CREATE INDEX idx_integrations_expiring ON integrations(token_expires_at)
  WHERE status = 'connected' AND token_expires_at IS NOT NULL;

-- ============================================================================
-- Row Level Security
-- ============================================================================
ALTER TABLE integrations ENABLE ROW LEVEL SECURITY;

CREATE POLICY integrations_select ON integrations
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY integrations_insert ON integrations
  FOR INSERT WITH CHECK (user_id = auth.uid());

CREATE POLICY integrations_update ON integrations
  FOR UPDATE USING (user_id = auth.uid());

CREATE POLICY integrations_delete ON integrations
  FOR DELETE USING (user_id = auth.uid());

-- ============================================================================
-- Trigger for updated_at
-- ============================================================================
CREATE TRIGGER integrations_updated_at
  BEFORE UPDATE ON integrations
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- Vault functions for secure credential storage
-- ============================================================================

-- Store a credential in vault
CREATE OR REPLACE FUNCTION store_credential(
  p_user_id UUID,
  p_provider TEXT,
  p_credential_type TEXT,
  p_credential_value TEXT
)
RETURNS void AS $$
DECLARE
  v_secret_name TEXT;
BEGIN
  v_secret_name := 'haven_' || p_user_id || '_' || p_provider || '_' || p_credential_type;
  
  -- Delete existing secret if any
  DELETE FROM vault.secrets WHERE name = v_secret_name;
  
  -- Insert new secret
  INSERT INTO vault.secrets (name, secret)
  VALUES (v_secret_name, p_credential_value);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Retrieve a credential from vault
CREATE OR REPLACE FUNCTION get_credential(
  p_user_id UUID,
  p_provider TEXT,
  p_credential_type TEXT
)
RETURNS TEXT AS $$
DECLARE
  v_secret_name TEXT;
  v_secret TEXT;
BEGIN
  v_secret_name := 'haven_' || p_user_id || '_' || p_provider || '_' || p_credential_type;
  
  SELECT decrypted_secret INTO v_secret
  FROM vault.decrypted_secrets
  WHERE name = v_secret_name;
  
  RETURN v_secret;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Delete credentials for a provider
CREATE OR REPLACE FUNCTION delete_credentials(
  p_user_id UUID,
  p_provider TEXT
)
RETURNS void AS $$
DECLARE
  v_prefix TEXT;
BEGIN
  v_prefix := 'haven_' || p_user_id || '_' || p_provider || '_';
  
  DELETE FROM vault.secrets WHERE name LIKE v_prefix || '%';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- Shopify-specific: Webhooks tracking
-- ============================================================================
CREATE TABLE shopify_webhooks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  shopify_webhook_id TEXT NOT NULL,
  topic TEXT NOT NULL,
  address TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_shopify_webhooks_user ON shopify_webhooks(user_id);

ALTER TABLE shopify_webhooks ENABLE ROW LEVEL SECURITY;

CREATE POLICY shopify_webhooks_all ON shopify_webhooks
  FOR ALL USING (user_id = auth.uid());
```

### `types/integrations.ts`
```typescript
export type IntegrationProvider =
  | 'shopify'
  | 'pinterest'
  | 'klaviyo'
  | 'dynamic_mockups'
  | 'resend'
  | 'sky_pilot';

export type IntegrationStatus =
  | 'disconnected'
  | 'connecting'
  | 'connected'
  | 'error'
  | 'expired';

export interface Integration {
  id: string;
  user_id: string;
  provider: IntegrationProvider;
  status: IntegrationStatus;
  metadata: IntegrationMetadata;
  last_error: string | null;
  last_error_at: string | null;
  token_expires_at: string | null;
  last_refreshed_at: string | null;
  connected_at: string | null;
  disconnected_at: string | null;
  created_at: string;
  updated_at: string;
}

export type IntegrationMetadata =
  | ShopifyMetadata
  | PinterestMetadata
  | KlaviyoMetadata
  | DynamicMockupsMetadata
  | ResendMetadata
  | SkyPilotMetadata;

export interface ShopifyMetadata {
  shop_domain: string;
  shop_name: string;
  access_scopes: string[];
}

export interface PinterestMetadata {
  account_name: string;
  account_id: string;
  board_count: number;
}

export interface KlaviyoMetadata {
  list_count: number;
  default_list_id?: string;
}

export interface DynamicMockupsMetadata {
  credits_remaining: number;
  plan: string;
}

export interface ResendMetadata {
  domain_verified: boolean;
  from_email: string;
}

export interface SkyPilotMetadata {
  connected: boolean;
}

export interface IntegrationConfig {
  provider: IntegrationProvider;
  name: string;
  description: string;
  icon: string;
  authType: 'oauth' | 'api_key';
  required: boolean;
  setupOrder: number;
  docsUrl: string;
}

export const INTEGRATION_CONFIGS: IntegrationConfig[] = [
  {
    provider: 'shopify',
    name: 'Shopify',
    description: 'Connect your store for products, orders, and customer data',
    icon: 'shopify',
    authType: 'oauth',
    required: true,
    setupOrder: 1,
    docsUrl: 'https://docs.havenhold.com/integrations/shopify',
  },
  {
    provider: 'pinterest',
    name: 'Pinterest',
    description: 'Publish pins, manage boards, and track analytics',
    icon: 'pinterest',
    authType: 'oauth',
    required: true,
    setupOrder: 2,
    docsUrl: 'https://docs.havenhold.com/integrations/pinterest',
  },
  {
    provider: 'klaviyo',
    name: 'Klaviyo',
    description: 'Email marketing, flows, and customer segments',
    icon: 'klaviyo',
    authType: 'api_key',
    required: true,
    setupOrder: 3,
    docsUrl: 'https://docs.havenhold.com/integrations/klaviyo',
  },
  {
    provider: 'dynamic_mockups',
    name: 'Dynamic Mockups',
    description: 'Generate product mockups automatically',
    icon: 'dynamic_mockups',
    authType: 'api_key',
    required: true,
    setupOrder: 4,
    docsUrl: 'https://docs.havenhold.com/integrations/dynamic-mockups',
  },
  {
    provider: 'resend',
    name: 'Resend',
    description: 'Transactional emails and notifications',
    icon: 'resend',
    authType: 'api_key',
    required: false,
    setupOrder: 5,
    docsUrl: 'https://docs.havenhold.com/integrations/resend',
  },
  {
    provider: 'sky_pilot',
    name: 'Sky Pilot',
    description: 'Digital product delivery for Shopify',
    icon: 'sky_pilot',
    authType: 'api_key',
    required: false,
    setupOrder: 6,
    docsUrl: 'https://docs.havenhold.com/integrations/sky-pilot',
  },
];
```

- **Step Dependencies**: Step 2.1
- **User Instructions**: Enable Vault extension in Supabase Dashboard → Database → Extensions

---

