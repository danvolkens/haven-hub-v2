## Step 21.3: Build Content Calendar UI

- **Task**: Create the unified content calendar interface showing all scheduled content.

- **Files**:

### `hooks/use-calendar.ts`
```typescript
'use client';

import { useQuery } from '@tanstack/react-query';
import { startOfMonth, endOfMonth, format } from 'date-fns';

export interface CalendarEvent {
  id: string;
  type: 'pin' | 'email' | 'campaign_task' | 'campaign_milestone';
  title: string;
  description?: string;
  scheduled_at: string;
  status: string;
  metadata: Record<string, any>;
}

export function useCalendarEvents(month: Date) {
  const start = format(startOfMonth(month), 'yyyy-MM-dd');
  const end = format(endOfMonth(month), 'yyyy-MM-dd');

  return useQuery({
    queryKey: ['calendar', start, end],
    queryFn: async () => {
      const response = await fetch(
        `/api/calendar?start=${start}&end=${end}`
      );
      if (!response.ok) throw new Error('Failed to fetch calendar');
      return response.json() as Promise<{ events: CalendarEvent[] }>;
    },
  });
}
```

### `app/api/calendar/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

export async function GET(request: NextRequest) {
  const supabase = createClient();
  
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const searchParams = request.nextUrl.searchParams;
  const start = searchParams.get('start');
  const end = searchParams.get('end');

  if (!start || !end) {
    return NextResponse.json({ error: 'start and end required' }, { status: 400 });
  }

  const events: any[] = [];

  // Fetch scheduled pins
  const { data: pins } = await supabase
    .from('pins')
    .select('id, title, description, scheduled_at, status, boards(name)')
    .eq('user_id', user.id)
    .gte('scheduled_at', start)
    .lte('scheduled_at', end)
    .not('scheduled_at', 'is', null);

  if (pins) {
    events.push(...pins.map(pin => ({
      id: pin.id,
      type: 'pin',
      title: pin.title,
      description: pin.description,
      scheduled_at: pin.scheduled_at,
      status: pin.status,
      metadata: { board: pin.boards?.name },
    })));
  }

  // Fetch campaign tasks
  const { data: tasks } = await supabase
    .from('campaign_tasks')
    .select(`
      id, 
      title, 
      description, 
      scheduled_at, 
      status,
      campaigns(name)
    `)
    .eq('user_id', user.id)
    .gte('scheduled_at', start)
    .lte('scheduled_at', end);

  if (tasks) {
    events.push(...tasks.map(task => ({
      id: task.id,
      type: 'campaign_task',
      title: task.title,
      description: task.description,
      scheduled_at: task.scheduled_at,
      status: task.status,
      metadata: { campaign: task.campaigns?.name },
    })));
  }

  // Fetch campaign milestones (start/end dates)
  const { data: campaigns } = await supabase
    .from('campaigns')
    .select('id, name, starts_at, ends_at, status')
    .eq('user_id', user.id)
    .or(`starts_at.gte.${start},ends_at.lte.${end}`);

  if (campaigns) {
    campaigns.forEach(campaign => {
      if (campaign.starts_at >= start && campaign.starts_at <= end) {
        events.push({
          id: `${campaign.id}-start`,
          type: 'campaign_milestone',
          title: `${campaign.name} - Launch`,
          scheduled_at: campaign.starts_at,
          status: campaign.status,
          metadata: { milestone: 'start', campaign_id: campaign.id },
        });
      }
      if (campaign.ends_at && campaign.ends_at >= start && campaign.ends_at <= end) {
        events.push({
          id: `${campaign.id}-end`,
          type: 'campaign_milestone',
          title: `${campaign.name} - End`,
          scheduled_at: campaign.ends_at,
          status: campaign.status,
          metadata: { milestone: 'end', campaign_id: campaign.id },
        });
      }
    });
  }

  // Sort by date
  events.sort((a, b) => 
    new Date(a.scheduled_at).getTime() - new Date(b.scheduled_at).getTime()
  );

  return NextResponse.json({ events });
}
```

### `components/calendar/content-calendar.tsx`
```tsx
'use client';

import { useState, useMemo } from 'react';
import {
  startOfMonth,
  endOfMonth,
  eachDayOfInterval,
  format,
  isSameMonth,
  isSameDay,
  addMonths,
  subMonths,
  startOfWeek,
  endOfWeek,
} from 'date-fns';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { useCalendarEvents, CalendarEvent } from '@/hooks/use-calendar';
import { ChevronLeft, ChevronRight, Pin, Mail, Flag, Calendar } from 'lucide-react';

const EVENT_COLORS: Record<string, string> = {
  pin: 'bg-red-100 text-red-700 border-red-200',
  email: 'bg-blue-100 text-blue-700 border-blue-200',
  campaign_task: 'bg-purple-100 text-purple-700 border-purple-200',
  campaign_milestone: 'bg-green-100 text-green-700 border-green-200',
};

const EVENT_ICONS: Record<string, any> = {
  pin: Pin,
  email: Mail,
  campaign_task: Flag,
  campaign_milestone: Calendar,
};

interface ContentCalendarProps {
  onEventClick?: (event: CalendarEvent) => void;
}

export function ContentCalendar({ onEventClick }: ContentCalendarProps) {
  const [currentMonth, setCurrentMonth] = useState(new Date());
  const { data, isLoading } = useCalendarEvents(currentMonth);

  const calendarDays = useMemo(() => {
    const monthStart = startOfMonth(currentMonth);
    const monthEnd = endOfMonth(currentMonth);
    const calendarStart = startOfWeek(monthStart);
    const calendarEnd = endOfWeek(monthEnd);

    return eachDayOfInterval({ start: calendarStart, end: calendarEnd });
  }, [currentMonth]);

  const eventsByDate = useMemo(() => {
    const map = new Map<string, CalendarEvent[]>();
    
    data?.events.forEach(event => {
      const dateKey = format(new Date(event.scheduled_at), 'yyyy-MM-dd');
      const existing = map.get(dateKey) || [];
      map.set(dateKey, [...existing, event]);
    });

    return map;
  }, [data?.events]);

  const goToPrevMonth = () => setCurrentMonth(subMonths(currentMonth, 1));
  const goToNextMonth = () => setCurrentMonth(addMonths(currentMonth, 1));
  const goToToday = () => setCurrentMonth(new Date());

  return (
    <div className="space-y-4">
      {/* Header */}
      <div className="flex items-center justify-between">
        <h2 className="text-2xl font-bold">
          {format(currentMonth, 'MMMM yyyy')}
        </h2>
        <div className="flex items-center gap-2">
          <Button variant="outline" size="sm" onClick={goToToday}>
            Today
          </Button>
          <Button variant="ghost" size="sm" onClick={goToPrevMonth}>
            <ChevronLeft className="h-4 w-4" />
          </Button>
          <Button variant="ghost" size="sm" onClick={goToNextMonth}>
            <ChevronRight className="h-4 w-4" />
          </Button>
        </div>
      </div>

      {/* Legend */}
      <div className="flex gap-4 text-sm">
        {Object.entries(EVENT_ICONS).map(([type, Icon]) => (
          <div key={type} className="flex items-center gap-1.5">
            <div className={`p-1 rounded ${EVENT_COLORS[type]}`}>
              <Icon className="h-3 w-3" />
            </div>
            <span className="capitalize">{type.replace('_', ' ')}</span>
          </div>
        ))}
      </div>

      {/* Calendar Grid */}
      <Card className="overflow-hidden">
        {/* Weekday Headers */}
        <div className="grid grid-cols-7 border-b bg-gray-50">
          {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map(day => (
            <div key={day} className="p-3 text-center text-sm font-medium">
              {day}
            </div>
          ))}
        </div>

        {/* Days Grid */}
        <div className="grid grid-cols-7">
          {calendarDays.map((day, index) => {
            const dateKey = format(day, 'yyyy-MM-dd');
            const dayEvents = eventsByDate.get(dateKey) || [];
            const isCurrentMonth = isSameMonth(day, currentMonth);
            const isToday = isSameDay(day, new Date());

            return (
              <div
                key={index}
                className={`min-h-[120px] border-b border-r p-2 ${
                  !isCurrentMonth ? 'bg-gray-50 text-muted-foreground' : ''
                } ${isToday ? 'bg-sage-50' : ''}`}
              >
                <div className={`text-sm font-medium mb-1 ${
                  isToday ? 'text-sage-600' : ''
                }`}>
                  {format(day, 'd')}
                </div>

                <div className="space-y-1">
                  {dayEvents.slice(0, 3).map(event => {
                    const Icon = EVENT_ICONS[event.type];
                    return (
                      <button
                        key={event.id}
                        onClick={() => onEventClick?.(event)}
                        className={`w-full text-left text-xs p-1.5 rounded border truncate flex items-center gap-1 hover:opacity-80 transition-opacity ${EVENT_COLORS[event.type]}`}
                      >
                        <Icon className="h-3 w-3 flex-shrink-0" />
                        <span className="truncate">{event.title}</span>
                      </button>
                    );
                  })}
                  {dayEvents.length > 3 && (
                    <div className="text-xs text-muted-foreground pl-1">
                      +{dayEvents.length - 3} more
                    </div>
                  )}
                </div>
              </div>
            );
          })}
        </div>
      </Card>
    </div>
  );
}
```

### `app/(dashboard)/dashboard/calendar/page.tsx`
```tsx
'use client';

import { useState } from 'react';
import { PageContainer } from '@/components/layout/page-container';
import { ContentCalendar } from '@/components/calendar/content-calendar';
import { Modal } from '@/components/ui/modal';
import { Badge } from '@/components/ui/badge';
import { CalendarEvent } from '@/hooks/use-calendar';
import { format } from 'date-fns';

export default function CalendarPage() {
  const [selectedEvent, setSelectedEvent] = useState<CalendarEvent | null>(null);

  return (
    <PageContainer
      title="Content Calendar"
      description="View all scheduled content in one place"
    >
      <ContentCalendar onEventClick={setSelectedEvent} />

      <Modal
        isOpen={!!selectedEvent}
        onClose={() => setSelectedEvent(null)}
        title={selectedEvent?.title || 'Event Details'}
      >
        {selectedEvent && (
          <div className="space-y-4">
            <div className="flex items-center gap-2">
              <Badge>{selectedEvent.type.replace('_', ' ')}</Badge>
              <Badge variant="outline">{selectedEvent.status}</Badge>
            </div>

            <div>
              <div className="text-sm text-muted-foreground">Scheduled</div>
              <div className="font-medium">
                {format(new Date(selectedEvent.scheduled_at), 'PPpp')}
              </div>
            </div>

            {selectedEvent.description && (
              <div>
                <div className="text-sm text-muted-foreground">Description</div>
                <div>{selectedEvent.description}</div>
              </div>
            )}

            {selectedEvent.metadata && Object.keys(selectedEvent.metadata).length > 0 && (
              <div>
                <div className="text-sm text-muted-foreground mb-1">Details</div>
                <div className="bg-gray-50 rounded-lg p-3 text-sm">
                  {Object.entries(selectedEvent.metadata).map(([key, value]) => (
                    <div key={key} className="flex justify-between">
                      <span className="text-muted-foreground capitalize">
                        {key.replace('_', ' ')}:
                      </span>
                      <span>{String(value)}</span>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}
      </Modal>
    </PageContainer>
  );
}
```

- **Step Dependencies**: Step 21.2
- **User Instructions**: None

---

