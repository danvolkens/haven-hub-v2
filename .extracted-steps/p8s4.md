## Step 12.1: Implement Analytics Sync Service

- **Task**: Create the service for syncing Pinterest analytics data.

- **Files**:

### `lib/pinterest/analytics-service.ts`
```typescript
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { getAdminClient } from '@/lib/supabase/admin';
import { PinterestClient } from '@/lib/integrations/pinterest/client';

interface AnalyticsSyncResult {
  success: boolean;
  pinsUpdated: number;
  errors: string[];
}

export async function syncPinAnalytics(userId: string): Promise<AnalyticsSyncResult> {
  const supabase = createServerSupabaseClient();
  const adminClient = getAdminClient();
  const errors: string[] = [];
  let pinsUpdated = 0;

  try {
    // Get Pinterest credentials
    const accessToken = await adminClient.rpc('get_credential', {
      p_user_id: userId,
      p_provider: 'pinterest',
      p_credential_type: 'access_token',
    });

    if (!accessToken.data) {
      throw new Error('Pinterest not connected');
    }

    const pinterestClient = new PinterestClient({ accessToken: accessToken.data });

    // Get all published pins
    const { data: pins } = await supabase
      .from('pins')
      .select('id, pinterest_pin_id')
      .eq('user_id', userId)
      .eq('status', 'published')
      .not('pinterest_pin_id', 'is', null);

    if (!pins || pins.length === 0) {
      return { success: true, pinsUpdated: 0, errors: [] };
    }

    // Calculate date range (last 30 days)
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - 30);

    const startDateStr = startDate.toISOString().split('T')[0];
    const endDateStr = endDate.toISOString().split('T')[0];

    // Sync analytics for each pin
    for (const pin of pins) {
      try {
        const analytics = await pinterestClient.getPinAnalytics(pin.pinterest_pin_id!, {
          start_date: startDateStr,
          end_date: endDateStr,
          metric_types: ['IMPRESSION', 'SAVE', 'PIN_CLICK', 'OUTBOUND_CLICK'],
        });

        // Calculate totals from daily metrics
        let impressions = 0;
        let saves = 0;
        let clicks = 0;
        let outboundClicks = 0;

        for (const day of analytics.daily_metrics || []) {
          impressions += day.metrics.IMPRESSION || 0;
          saves += day.metrics.SAVE || 0;
          clicks += day.metrics.PIN_CLICK || 0;
          outboundClicks += day.metrics.OUTBOUND_CLICK || 0;
        }

        // Determine performance tier
        const engagementRate = impressions > 0 ? (saves + clicks) / impressions : 0;
        let performanceTier: string;
        
        if (engagementRate >= 0.05) {
          performanceTier = 'top';
        } else if (engagementRate >= 0.02) {
          performanceTier = 'good';
        } else if (engagementRate >= 0.01) {
          performanceTier = 'average';
        } else {
          performanceTier = 'underperformer';
        }

        // Update pin
        await supabase
          .from('pins')
          .update({
            impressions,
            saves,
            clicks,
            outbound_clicks: outboundClicks,
            performance_tier: performanceTier,
            last_metrics_sync: new Date().toISOString(),
          })
          .eq('id', pin.id);

        pinsUpdated++;
      } catch (error) {
        errors.push(`Pin ${pin.id}: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }

    // Update copy template performance
    await updateCopyTemplatePerformance(userId);

    // Log activity
    await supabase.rpc('log_activity', {
      p_user_id: userId,
      p_action_type: 'analytics_synced',
      p_details: { pinsUpdated, errors: errors.length },
      p_executed: true,
      p_module: 'pinterest',
    });

    return { success: true, pinsUpdated, errors };
  } catch (error) {
    console.error('Analytics sync error:', error);
    return {
      success: false,
      pinsUpdated,
      errors: [error instanceof Error ? error.message : 'Unknown error'],
    };
  }
}

async function updateCopyTemplatePerformance(userId: string) {
  const supabase = createServerSupabaseClient();

  // Get all templates with their pin performance
  const { data: templates } = await supabase
    .from('pin_copy_templates')
    .select('id')
    .eq('user_id', userId);

  if (!templates) return;

  for (const template of templates) {
    // Aggregate performance from all pins using this template
    const { data: stats } = await supabase
      .from('pins')
      .select('impressions, saves, clicks')
      .eq('user_id', userId)
      .eq('copy_template_id', template.id)
      .eq('status', 'published');

    if (stats && stats.length > 0) {
      const totalImpressions = stats.reduce((sum, p) => sum + p.impressions, 0);
      const totalSaves = stats.reduce((sum, p) => sum + p.saves, 0);
      const totalClicks = stats.reduce((sum, p) => sum + p.clicks, 0);
      const avgEngagement = totalImpressions > 0 
        ? (totalSaves + totalClicks) / totalImpressions 
        : null;

      await supabase
        .from('pin_copy_templates')
        .update({
          total_impressions: totalImpressions,
          total_saves: totalSaves,
          total_clicks: totalClicks,
          avg_engagement_rate: avgEngagement,
        })
        .eq('id', template.id);
    }
  }
}

export async function getTopPerformingPins(
  userId: string,
  limit: number = 10
): Promise<{ pins: any[]; error?: string }> {
  const supabase = createServerSupabaseClient();

  const { data, error } = await supabase
    .from('pins')
    .select(`
      *,
      asset:assets(file_url, quotes(text)),
      mockup:mockups(file_url)
    `)
    .eq('user_id', userId)
    .eq('status', 'published')
    .in('performance_tier', ['top', 'good'])
    .order('engagement_rate', { ascending: false, nullsFirst: false })
    .limit(limit);

  if (error) {
    return { pins: [], error: error.message };
  }

  return { pins: data || [] };
}

export async function getUnderperformingPins(
  userId: string,
  daysThreshold: number = 7
): Promise<{ pins: any[]; error?: string }> {
  const supabase = createServerSupabaseClient();
  
  const thresholdDate = new Date();
  thresholdDate.setDate(thresholdDate.getDate() - daysThreshold);

  const { data, error } = await supabase
    .from('pins')
    .select('*')
    .eq('user_id', userId)
    .eq('status', 'published')
    .eq('performance_tier', 'underperformer')
    .lt('published_at', thresholdDate.toISOString());

  if (error) {
    return { pins: [], error: error.message };
  }

  return { pins: data || [] };
}
```

- **Step Dependencies**: Step 11.3
- **User Instructions**: None

---

