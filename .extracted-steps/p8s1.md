## Step 11.1: Create Pinterest Database Schema

- **Task**: Create database schema for pins, boards, and scheduling.

- **Files**:

### `supabase/migrations/009_pinterest.sql`
```sql
-- ============================================================================
-- Migration: 009_pinterest
-- Description: Pinterest pins, boards, and scheduling
-- Feature: 11 (Pinterest Core)
-- ============================================================================

-- ============================================================================
-- Pinterest Boards Table
-- ============================================================================
CREATE TABLE pinterest_boards (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  
  -- Pinterest references
  pinterest_board_id TEXT NOT NULL,
  
  -- Board details
  name TEXT NOT NULL,
  description TEXT,
  privacy TEXT DEFAULT 'PUBLIC' CHECK (privacy IN ('PUBLIC', 'PROTECTED', 'SECRET')),
  
  -- Stats (synced from Pinterest)
  pin_count INTEGER NOT NULL DEFAULT 0,
  follower_count INTEGER NOT NULL DEFAULT 0,
  
  -- Haven Hub metadata
  collection TEXT CHECK (collection IN ('grounding', 'wholeness', 'growth')),
  is_primary BOOLEAN NOT NULL DEFAULT false, -- Primary board for this collection
  
  -- Sync status
  synced_at TIMESTAMPTZ,
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  UNIQUE(user_id, pinterest_board_id)
);

-- ============================================================================
-- Pins Table
-- ============================================================================
CREATE TABLE pins (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  
  -- Source references
  asset_id UUID REFERENCES assets(id) ON DELETE SET NULL,
  mockup_id UUID REFERENCES mockups(id) ON DELETE SET NULL,
  quote_id UUID REFERENCES quotes(id) ON DELETE SET NULL,
  
  -- Pinterest references
  pinterest_pin_id TEXT,
  pinterest_board_id TEXT NOT NULL,
  board_id UUID REFERENCES pinterest_boards(id) ON DELETE SET NULL,
  
  -- Pin content
  title TEXT NOT NULL,
  description TEXT,
  link TEXT, -- Product link
  alt_text TEXT,
  
  -- Image
  image_url TEXT NOT NULL,
  
  -- Copy variant tracking (Feature 12)
  copy_variant TEXT, -- 'a', 'b', 'c', etc.
  copy_template_id UUID,
  
  -- Classification
  collection TEXT CHECK (collection IN ('grounding', 'wholeness', 'growth')),
  
  -- Scheduling
  status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN (
    'draft',        -- Not scheduled
    'scheduled',    -- Queued for publishing
    'publishing',   -- Currently being published
    'published',    -- Live on Pinterest
    'failed',       -- Publishing failed
    'retired'       -- Removed/retired
  )),
  scheduled_for TIMESTAMPTZ,
  published_at TIMESTAMPTZ,
  
  -- Performance metrics (synced from Pinterest Analytics)
  impressions INTEGER NOT NULL DEFAULT 0,
  saves INTEGER NOT NULL DEFAULT 0,
  clicks INTEGER NOT NULL DEFAULT 0,
  outbound_clicks INTEGER NOT NULL DEFAULT 0,
  engagement_rate NUMERIC(5,4), -- saves + clicks / impressions
  
  -- Performance tracking
  last_metrics_sync TIMESTAMPTZ,
  performance_tier TEXT CHECK (performance_tier IN ('top', 'good', 'average', 'underperformer')),
  
  -- Error tracking
  last_error TEXT,
  retry_count INTEGER NOT NULL DEFAULT 0,
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================================================
-- Pin Schedule Table (for recurring/batch scheduling)
-- ============================================================================
CREATE TABLE pin_schedules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  
  -- Schedule configuration
  name TEXT NOT NULL,
  is_active BOOLEAN NOT NULL DEFAULT true,
  
  -- Time slots (per spec: optimal Pinterest posting times)
  time_slots JSONB NOT NULL DEFAULT '[
    {"day": 0, "hour": 20, "minute": 0},
    {"day": 1, "hour": 20, "minute": 0},
    {"day": 2, "hour": 20, "minute": 0},
    {"day": 3, "hour": 20, "minute": 0},
    {"day": 4, "hour": 20, "minute": 0},
    {"day": 5, "hour": 14, "minute": 0},
    {"day": 6, "hour": 14, "minute": 0}
  ]',
  
  -- Timezone
  timezone TEXT NOT NULL DEFAULT 'America/New_York',
  
  -- Limits (respects guardrails)
  max_pins_per_day INTEGER NOT NULL DEFAULT 5,
  
  -- Rotation settings
  rotate_collections BOOLEAN NOT NULL DEFAULT true,
  collection_weights JSONB DEFAULT '{"grounding": 0.33, "wholeness": 0.33, "growth": 0.34}',
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================================================
-- Copy Templates Table (for A/B testing pin descriptions)
-- ============================================================================
CREATE TABLE pin_copy_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  
  -- Template details
  name TEXT NOT NULL,
  variant TEXT NOT NULL DEFAULT 'a', -- 'a', 'b', 'c'
  
  -- Template content (supports variables)
  title_template TEXT NOT NULL,
  description_template TEXT NOT NULL,
  -- Variables: {quote}, {collection}, {mood}, {product_link}, {shop_name}
  
  -- Targeting
  collection TEXT CHECK (collection IN ('grounding', 'wholeness', 'growth')),
  mood TEXT,
  
  -- Performance
  times_used INTEGER NOT NULL DEFAULT 0,
  total_impressions INTEGER NOT NULL DEFAULT 0,
  total_saves INTEGER NOT NULL DEFAULT 0,
  total_clicks INTEGER NOT NULL DEFAULT 0,
  avg_engagement_rate NUMERIC(5,4),
  
  is_active BOOLEAN NOT NULL DEFAULT true,
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================================================
-- Indexes
-- ============================================================================
CREATE INDEX idx_boards_user ON pinterest_boards(user_id);
CREATE INDEX idx_boards_collection ON pinterest_boards(user_id, collection);
CREATE INDEX idx_boards_pinterest ON pinterest_boards(pinterest_board_id);

CREATE INDEX idx_pins_user ON pins(user_id);
CREATE INDEX idx_pins_status ON pins(user_id, status);
CREATE INDEX idx_pins_scheduled ON pins(scheduled_for, status) WHERE status = 'scheduled';
CREATE INDEX idx_pins_asset ON pins(asset_id) WHERE asset_id IS NOT NULL;
CREATE INDEX idx_pins_mockup ON pins(mockup_id) WHERE mockup_id IS NOT NULL;
CREATE INDEX idx_pins_pinterest ON pins(pinterest_pin_id) WHERE pinterest_pin_id IS NOT NULL;
CREATE INDEX idx_pins_performance ON pins(user_id, performance_tier, impressions DESC);
CREATE INDEX idx_pins_collection ON pins(user_id, collection, status);

CREATE INDEX idx_copy_templates_user ON pin_copy_templates(user_id);
CREATE INDEX idx_copy_templates_collection ON pin_copy_templates(user_id, collection);

-- ============================================================================
-- Row Level Security
-- ============================================================================
ALTER TABLE pinterest_boards ENABLE ROW LEVEL SECURITY;
ALTER TABLE pins ENABLE ROW LEVEL SECURITY;
ALTER TABLE pin_schedules ENABLE ROW LEVEL SECURITY;
ALTER TABLE pin_copy_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY boards_all ON pinterest_boards FOR ALL USING (user_id = auth.uid());
CREATE POLICY pins_all ON pins FOR ALL USING (user_id = auth.uid());
CREATE POLICY schedules_all ON pin_schedules FOR ALL USING (user_id = auth.uid());
CREATE POLICY copy_templates_all ON pin_copy_templates FOR ALL USING (user_id = auth.uid());

CREATE TRIGGER boards_updated_at BEFORE UPDATE ON pinterest_boards
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER pins_updated_at BEFORE UPDATE ON pins
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER schedules_updated_at BEFORE UPDATE ON pin_schedules
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER copy_updated_at BEFORE UPDATE ON pin_copy_templates
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- Function: Get next available schedule slot
-- ============================================================================
CREATE OR REPLACE FUNCTION get_next_pin_slot(
  p_user_id UUID,
  p_after TIMESTAMPTZ DEFAULT NOW()
)
RETURNS TIMESTAMPTZ AS $$
DECLARE
  v_schedule RECORD;
  v_slot RECORD;
  v_next_slot TIMESTAMPTZ;
  v_pins_on_day INTEGER;
  v_max_pins INTEGER;
  v_check_date DATE;
  v_slot_time TIME;
BEGIN
  -- Get user's schedule
  SELECT * INTO v_schedule
  FROM pin_schedules
  WHERE user_id = p_user_id AND is_active = true
  LIMIT 1;
  
  IF NOT FOUND THEN
    -- Default: next hour
    RETURN date_trunc('hour', p_after) + INTERVAL '1 hour';
  END IF;
  
  v_max_pins := LEAST(v_schedule.max_pins_per_day, 
    COALESCE((SELECT (guardrails->>'daily_pin_limit')::INTEGER FROM user_settings WHERE user_id = p_user_id), 5)
  );
  
  -- Check each day starting from p_after
  FOR i IN 0..30 LOOP
    v_check_date := (p_after AT TIME ZONE v_schedule.timezone)::DATE + i;
    
    -- Count pins already scheduled for this day
    SELECT COUNT(*) INTO v_pins_on_day
    FROM pins
    WHERE user_id = p_user_id
      AND status IN ('scheduled', 'publishing', 'published')
      AND (scheduled_for AT TIME ZONE v_schedule.timezone)::DATE = v_check_date;
    
    IF v_pins_on_day < v_max_pins THEN
      -- Find available slot on this day
      FOR v_slot IN 
        SELECT * FROM jsonb_array_elements(v_schedule.time_slots) AS slot
        WHERE (slot->>'day')::INTEGER = EXTRACT(DOW FROM v_check_date)
        ORDER BY (slot->>'hour')::INTEGER, (slot->>'minute')::INTEGER
      LOOP
        v_slot_time := make_time(
          (v_slot.slot->>'hour')::INTEGER,
          (v_slot.slot->>'minute')::INTEGER,
          0
        );
        v_next_slot := (v_check_date + v_slot_time) AT TIME ZONE v_schedule.timezone;
        
        -- Check if slot is available and in the future
        IF v_next_slot > p_after THEN
          -- Check if slot is not already taken
          IF NOT EXISTS (
            SELECT 1 FROM pins
            WHERE user_id = p_user_id
              AND status = 'scheduled'
              AND scheduled_for = v_next_slot
          ) THEN
            RETURN v_next_slot;
          END IF;
        END IF;
      END LOOP;
    END IF;
  END LOOP;
  
  -- Fallback: 1 hour from now
  RETURN date_trunc('hour', p_after) + INTERVAL '1 hour';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- Function: Calculate engagement rate
-- ============================================================================
CREATE OR REPLACE FUNCTION calculate_engagement_rate()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.impressions > 0 THEN
    NEW.engagement_rate := (NEW.saves + NEW.clicks)::NUMERIC / NEW.impressions;
  ELSE
    NEW.engagement_rate := NULL;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER pins_engagement_rate
  BEFORE INSERT OR UPDATE OF impressions, saves, clicks ON pins
  FOR EACH ROW EXECUTE FUNCTION calculate_engagement_rate();
```

### `types/pinterest.ts`
```typescript
export interface PinterestBoard {
  id: string;
  user_id: string;
  pinterest_board_id: string;
  name: string;
  description: string | null;
  privacy: 'PUBLIC' | 'PROTECTED' | 'SECRET';
  pin_count: number;
  follower_count: number;
  collection: 'grounding' | 'wholeness' | 'growth' | null;
  is_primary: boolean;
  synced_at: string | null;
  created_at: string;
  updated_at: string;
}

export interface Pin {
  id: string;
  user_id: string;
  asset_id: string | null;
  mockup_id: string | null;
  quote_id: string | null;
  pinterest_pin_id: string | null;
  pinterest_board_id: string;
  board_id: string | null;
  title: string;
  description: string | null;
  link: string | null;
  alt_text: string | null;
  image_url: string;
  copy_variant: string | null;
  copy_template_id: string | null;
  collection: 'grounding' | 'wholeness' | 'growth' | null;
  status: PinStatus;
  scheduled_for: string | null;
  published_at: string | null;
  impressions: number;
  saves: number;
  clicks: number;
  outbound_clicks: number;
  engagement_rate: number | null;
  last_metrics_sync: string | null;
  performance_tier: 'top' | 'good' | 'average' | 'underperformer' | null;
  last_error: string | null;
  retry_count: number;
  created_at: string;
  updated_at: string;
}

export type PinStatus = 
  | 'draft' 
  | 'scheduled' 
  | 'publishing' 
  | 'published' 
  | 'failed' 
  | 'retired';

export interface PinSchedule {
  id: string;
  user_id: string;
  name: string;
  is_active: boolean;
  time_slots: TimeSlot[];
  timezone: string;
  max_pins_per_day: number;
  rotate_collections: boolean;
  collection_weights: Record<string, number>;
  created_at: string;
  updated_at: string;
}

export interface TimeSlot {
  day: number; // 0-6, Sunday = 0
  hour: number;
  minute: number;
}

export interface PinCopyTemplate {
  id: string;
  user_id: string;
  name: string;
  variant: string;
  title_template: string;
  description_template: string;
  collection: 'grounding' | 'wholeness' | 'growth' | null;
  mood: string | null;
  times_used: number;
  total_impressions: number;
  total_saves: number;
  total_clicks: number;
  avg_engagement_rate: number | null;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

export interface CreatePinRequest {
  assetId?: string;
  mockupId?: string;
  boardId: string;
  title: string;
  description?: string;
  link?: string;
  scheduledFor?: string;
  copyTemplateId?: string;
}

export interface SchedulePinRequest {
  pinIds: string[];
  startFrom?: string;
  respectSchedule?: boolean;
}
```

- **Step Dependencies**: Step 5.3
- **User Instructions**: Run migration

---

