## Step 6.3: Implement Data Export System

- **Task**: Create streaming export functionality for large datasets with format and field selection.

- **Files**:

### `lib/export/export-config.ts`
```typescript
// Export configuration for each data type

export type ExportType = 
  | 'leads'
  | 'customers'
  | 'orders'
  | 'pins'
  | 'quotes'
  | 'assets'
  | 'analytics';

export type ExportFormat = 'csv' | 'json';

export interface ExportField {
  key: string;
  label: string;
  default: boolean;
  formatter?: (value: any) => string;
}

export interface ExportConfig {
  type: ExportType;
  label: string;
  description: string;
  fields: ExportField[];
  defaultDateRange: number; // days
  maxRecords: number;
}

export const EXPORT_CONFIGS: Record<ExportType, ExportConfig> = {
  leads: {
    type: 'leads',
    label: 'Leads',
    description: 'Quiz responses and email subscribers',
    defaultDateRange: 30,
    maxRecords: 50000,
    fields: [
      { key: 'id', label: 'ID', default: true },
      { key: 'email', label: 'Email', default: true },
      { key: 'segment', label: 'Segment', default: true },
      { key: 'source', label: 'Source', default: true },
      { key: 'quiz_completed', label: 'Quiz Completed', default: true },
      { key: 'converted', label: 'Converted to Customer', default: true },
      { key: 'created_at', label: 'Created At', default: true },
      { key: 'utm_source', label: 'UTM Source', default: false },
      { key: 'utm_medium', label: 'UTM Medium', default: false },
      { key: 'utm_campaign', label: 'UTM Campaign', default: false },
    ],
  },
  customers: {
    type: 'customers',
    label: 'Customers',
    description: 'Customer profiles and purchase history',
    defaultDateRange: 90,
    maxRecords: 50000,
    fields: [
      { key: 'id', label: 'ID', default: true },
      { key: 'email', label: 'Email', default: true },
      { key: 'shopify_customer_id', label: 'Shopify ID', default: true },
      { key: 'segment', label: 'Segment', default: true },
      { key: 'order_count', label: 'Order Count', default: true },
      { key: 'total_spent', label: 'Total Spent', default: true },
      { key: 'first_order_at', label: 'First Order', default: true },
      { key: 'last_order_at', label: 'Last Order', default: true },
      { key: 'journey_stage', label: 'Journey Stage', default: true },
      { key: 'loyalty_tier', label: 'Loyalty Tier', default: false },
      { key: 'lifetime_points', label: 'Lifetime Points', default: false },
    ],
  },
  orders: {
    type: 'orders',
    label: 'Orders',
    description: 'Order history with line items',
    defaultDateRange: 90,
    maxRecords: 100000,
    fields: [
      { key: 'id', label: 'ID', default: true },
      { key: 'shopify_order_id', label: 'Shopify Order ID', default: true },
      { key: 'customer_email', label: 'Customer Email', default: true },
      { key: 'total', label: 'Total', default: true },
      { key: 'subtotal', label: 'Subtotal', default: true },
      { key: 'discount_total', label: 'Discount', default: true },
      { key: 'item_count', label: 'Item Count', default: true },
      { key: 'status', label: 'Status', default: true },
      { key: 'created_at', label: 'Created At', default: true },
      { key: 'attribution_channel', label: 'Attribution Channel', default: false },
      { key: 'coupon_code', label: 'Coupon Code', default: false },
    ],
  },
  pins: {
    type: 'pins',
    label: 'Pinterest Pins',
    description: 'Pin performance and scheduling data',
    defaultDateRange: 30,
    maxRecords: 10000,
    fields: [
      { key: 'id', label: 'ID', default: true },
      { key: 'title', label: 'Title', default: true },
      { key: 'board_name', label: 'Board', default: true },
      { key: 'status', label: 'Status', default: true },
      { key: 'impressions', label: 'Impressions', default: true },
      { key: 'saves', label: 'Saves', default: true },
      { key: 'clicks', label: 'Clicks', default: true },
      { key: 'engagement_rate', label: 'Engagement Rate', default: true },
      { key: 'published_at', label: 'Published At', default: true },
      { key: 'link', label: 'Link', default: false },
      { key: 'pinterest_pin_id', label: 'Pinterest ID', default: false },
    ],
  },
  quotes: {
    type: 'quotes',
    label: 'Quotes',
    description: 'Quote content and generation data',
    defaultDateRange: 90,
    maxRecords: 10000,
    fields: [
      { key: 'id', label: 'ID', default: true },
      { key: 'text', label: 'Text', default: true },
      { key: 'attribution', label: 'Attribution', default: true },
      { key: 'collection', label: 'Collection', default: true },
      { key: 'mood', label: 'Mood', default: true },
      { key: 'status', label: 'Status', default: true },
      { key: 'assets_count', label: 'Assets Generated', default: true },
      { key: 'created_at', label: 'Created At', default: true },
    ],
  },
  assets: {
    type: 'assets',
    label: 'Assets',
    description: 'Generated design assets',
    defaultDateRange: 90,
    maxRecords: 50000,
    fields: [
      { key: 'id', label: 'ID', default: true },
      { key: 'quote_text', label: 'Quote', default: true },
      { key: 'format', label: 'Format', default: true },
      { key: 'status', label: 'Status', default: true },
      { key: 'quality_score', label: 'Quality Score', default: true },
      { key: 'url', label: 'URL', default: true },
      { key: 'created_at', label: 'Created At', default: true },
    ],
  },
  analytics: {
    type: 'analytics',
    label: 'Analytics',
    description: 'Daily performance metrics',
    defaultDateRange: 30,
    maxRecords: 1000,
    fields: [
      { key: 'date', label: 'Date', default: true },
      { key: 'revenue', label: 'Revenue', default: true },
      { key: 'orders', label: 'Orders', default: true },
      { key: 'new_customers', label: 'New Customers', default: true },
      { key: 'new_leads', label: 'New Leads', default: true },
      { key: 'quiz_completions', label: 'Quiz Completions', default: true },
      { key: 'pin_impressions', label: 'Pin Impressions', default: true },
      { key: 'pin_clicks', label: 'Pin Clicks', default: true },
    ],
  },
};
```

### `lib/export/export-service.ts`
```typescript
import { createClient } from '@/lib/supabase/server';
import { EXPORT_CONFIGS, ExportType, ExportFormat, ExportField } from './export-config';

export interface ExportOptions {
  type: ExportType;
  format: ExportFormat;
  fields: string[];
  startDate?: Date;
  endDate?: Date;
  limit?: number;
}

export interface ExportResult {
  data: string;
  filename: string;
  mimeType: string;
  recordCount: number;
}

// Get query for each export type
function getExportQuery(
  supabase: any,
  type: ExportType,
  userId: string,
  startDate?: Date,
  endDate?: Date
) {
  const start = startDate?.toISOString();
  const end = endDate?.toISOString();

  switch (type) {
    case 'leads':
      let leadsQuery = supabase
        .from('leads')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false });
      if (start) leadsQuery = leadsQuery.gte('created_at', start);
      if (end) leadsQuery = leadsQuery.lte('created_at', end);
      return leadsQuery;

    case 'customers':
      let customersQuery = supabase
        .from('customers')
        .select(`
          *,
          customer_loyalty(tier, points_balance, lifetime_points_earned)
        `)
        .eq('user_id', userId)
        .order('created_at', { ascending: false });
      if (start) customersQuery = customersQuery.gte('created_at', start);
      if (end) customersQuery = customersQuery.lte('created_at', end);
      return customersQuery;

    case 'orders':
      let ordersQuery = supabase
        .from('customer_orders')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false });
      if (start) ordersQuery = ordersQuery.gte('created_at', start);
      if (end) ordersQuery = ordersQuery.lte('created_at', end);
      return ordersQuery;

    case 'pins':
      let pinsQuery = supabase
        .from('pins')
        .select(`
          *,
          boards(name),
          pin_analytics(impressions, saves, clicks, engagement_rate)
        `)
        .eq('user_id', userId)
        .order('created_at', { ascending: false });
      if (start) pinsQuery = pinsQuery.gte('created_at', start);
      if (end) pinsQuery = pinsQuery.lte('created_at', end);
      return pinsQuery;

    case 'quotes':
      let quotesQuery = supabase
        .from('quotes')
        .select(`
          *,
          assets(count)
        `)
        .eq('user_id', userId)
        .order('created_at', { ascending: false });
      if (start) quotesQuery = quotesQuery.gte('created_at', start);
      if (end) quotesQuery = quotesQuery.lte('created_at', end);
      return quotesQuery;

    case 'assets':
      let assetsQuery = supabase
        .from('assets')
        .select(`
          *,
          quotes(text)
        `)
        .eq('user_id', userId)
        .order('created_at', { ascending: false });
      if (start) assetsQuery = assetsQuery.gte('created_at', start);
      if (end) assetsQuery = assetsQuery.lte('created_at', end);
      return assetsQuery;

    case 'analytics':
      let analyticsQuery = supabase
        .from('daily_metrics')
        .select('*')
        .eq('user_id', userId)
        .order('date', { ascending: false });
      if (start) analyticsQuery = analyticsQuery.gte('date', start.split('T')[0]);
      if (end) analyticsQuery = analyticsQuery.lte('date', end.split('T')[0]);
      return analyticsQuery;

    default:
      throw new Error(`Unknown export type: ${type}`);
  }
}

// Transform row data based on field selection
function transformRow(row: any, type: ExportType, fields: string[]): Record<string, any> {
  const result: Record<string, any> = {};

  for (const field of fields) {
    switch (type) {
      case 'pins':
        if (field === 'board_name') {
          result[field] = row.boards?.name || '';
        } else if (['impressions', 'saves', 'clicks', 'engagement_rate'].includes(field)) {
          result[field] = row.pin_analytics?.[0]?.[field] || 0;
        } else {
          result[field] = row[field];
        }
        break;

      case 'customers':
        if (field === 'loyalty_tier') {
          result[field] = row.customer_loyalty?.tier || 'none';
        } else if (field === 'lifetime_points') {
          result[field] = row.customer_loyalty?.lifetime_points_earned || 0;
        } else {
          result[field] = row[field];
        }
        break;

      case 'assets':
        if (field === 'quote_text') {
          result[field] = row.quotes?.text || '';
        } else {
          result[field] = row[field];
        }
        break;

      case 'quotes':
        if (field === 'assets_count') {
          result[field] = row.assets?.[0]?.count || 0;
        } else {
          result[field] = row[field];
        }
        break;

      default:
        result[field] = row[field];
    }
  }

  return result;
}

// Format value for CSV
function formatCSVValue(value: any): string {
  if (value === null || value === undefined) return '';
  if (typeof value === 'object') return JSON.stringify(value);
  const str = String(value);
  // Escape quotes and wrap in quotes if contains comma, quote, or newline
  if (str.includes(',') || str.includes('"') || str.includes('\n')) {
    return `"${str.replace(/"/g, '""')}"`;
  }
  return str;
}

// Generate CSV output
function generateCSV(data: Record<string, any>[], fields: string[]): string {
  const config = EXPORT_CONFIGS[data[0]?.type as ExportType];
  const fieldLabels = fields.map(f => {
    const field = config?.fields.find(cf => cf.key === f);
    return field?.label || f;
  });

  const header = fieldLabels.join(',');
  const rows = data.map(row => 
    fields.map(f => formatCSVValue(row[f])).join(',')
  );

  return [header, ...rows].join('\n');
}

// Generate JSON output
function generateJSON(data: Record<string, any>[]): string {
  return JSON.stringify(data, null, 2);
}

// Main export function
export async function generateExport(
  userId: string,
  options: ExportOptions
): Promise<ExportResult> {
  const supabase = createClient();
  const config = EXPORT_CONFIGS[options.type];
  
  if (!config) {
    throw new Error(`Invalid export type: ${options.type}`);
  }

  // Validate fields
  const validFields = config.fields.map(f => f.key);
  const selectedFields = options.fields.filter(f => validFields.includes(f));
  
  if (selectedFields.length === 0) {
    // Use default fields
    selectedFields.push(...config.fields.filter(f => f.default).map(f => f.key));
  }

  // Build and execute query
  const query = getExportQuery(
    supabase,
    options.type,
    userId,
    options.startDate,
    options.endDate
  );

  const limit = Math.min(options.limit || config.maxRecords, config.maxRecords);
  const { data, error } = await query.limit(limit);

  if (error) {
    throw new Error(`Export query failed: ${error.message}`);
  }

  if (!data || data.length === 0) {
    // Return empty file
    const emptyData = options.format === 'csv' 
      ? selectedFields.join(',')
      : '[]';
    
    return {
      data: emptyData,
      filename: `${options.type}-export-${Date.now()}.${options.format}`,
      mimeType: options.format === 'csv' ? 'text/csv' : 'application/json',
      recordCount: 0,
    };
  }

  // Transform data
  const transformedData = data.map(row => 
    transformRow(row, options.type, selectedFields)
  );

  // Generate output
  const output = options.format === 'csv'
    ? generateCSV(transformedData, selectedFields)
    : generateJSON(transformedData);

  const timestamp = new Date().toISOString().split('T')[0];
  
  return {
    data: output,
    filename: `${options.type}-export-${timestamp}.${options.format}`,
    mimeType: options.format === 'csv' ? 'text/csv' : 'application/json',
    recordCount: transformedData.length,
  };
}

// Record export in history
export async function recordExport(
  userId: string,
  options: ExportOptions,
  recordCount: number
): Promise<void> {
  const supabase = createClient();
  
  await supabase.from('export_history').insert({
    user_id: userId,
    export_type: options.type,
    format: options.format,
    fields: options.fields,
    start_date: options.startDate?.toISOString(),
    end_date: options.endDate?.toISOString(),
    record_count: recordCount,
    created_at: new Date().toISOString(),
  });
}
```

### `app/api/export/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { generateExport, recordExport, ExportOptions } from '@/lib/export/export-service';
import { EXPORT_CONFIGS, ExportType, ExportFormat } from '@/lib/export/export-config';

export async function GET(request: NextRequest) {
  const supabase = createClient();
  
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const searchParams = request.nextUrl.searchParams;
  const type = searchParams.get('type') as ExportType;
  const format = (searchParams.get('format') || 'csv') as ExportFormat;
  const fields = searchParams.get('fields')?.split(',') || [];
  const startDate = searchParams.get('startDate');
  const endDate = searchParams.get('endDate');
  const limit = searchParams.get('limit');

  // Validate type
  if (!type || !EXPORT_CONFIGS[type]) {
    return NextResponse.json(
      { error: 'Invalid export type' },
      { status: 400 }
    );
  }

  // Validate format
  if (!['csv', 'json'].includes(format)) {
    return NextResponse.json(
      { error: 'Invalid format. Must be csv or json' },
      { status: 400 }
    );
  }

  try {
    const options: ExportOptions = {
      type,
      format,
      fields,
      startDate: startDate ? new Date(startDate) : undefined,
      endDate: endDate ? new Date(endDate) : undefined,
      limit: limit ? parseInt(limit, 10) : undefined,
    };

    const result = await generateExport(user.id, options);

    // Record export in history
    await recordExport(user.id, options, result.recordCount);

    // Return file as download
    return new NextResponse(result.data, {
      status: 200,
      headers: {
        'Content-Type': result.mimeType,
        'Content-Disposition': `attachment; filename="${result.filename}"`,
        'X-Record-Count': String(result.recordCount),
      },
    });
  } catch (error) {
    console.error('Export error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Export failed' },
      { status: 500 }
    );
  }
}

// Get export configuration
export async function POST(request: NextRequest) {
  const supabase = createClient();
  
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Return all export configs
  return NextResponse.json({
    configs: Object.values(EXPORT_CONFIGS),
  });
}
```

- **Step Dependencies**: Step 6.2
- **User Instructions**: None

---

