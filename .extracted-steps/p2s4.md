## Step 2.1: Create Core Database Schema - User Settings

- **Task**: Create the Supabase migration for user_settings table with operator mode, guardrails, and setup tracking per Feature 1 spec.

- **Files**:

### `supabase/migrations/001_user_settings.sql`
```sql
-- ============================================================================
-- Migration: 001_user_settings
-- Description: Core user settings table with operator mode, guardrails, and setup tracking
-- Feature: 1 (Operator Mode System), 3 (Setup Wizard), 6 (Daily Digest)
-- ============================================================================

-- Create updated_at trigger function (reusable for all tables)
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- User Settings Table
-- ============================================================================
CREATE TABLE user_settings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE NOT NULL,
  
  -- Operator Mode (Feature 1)
  -- supervised: all actions require approval
  -- assisted: only high-risk actions require approval
  -- autopilot: automatic execution within guardrails
  global_mode TEXT NOT NULL DEFAULT 'supervised' 
    CHECK (global_mode IN ('supervised', 'assisted', 'autopilot')),
  
  -- Module-specific overrides (e.g., {"pinterest": "autopilot", "mockups": "supervised"})
  module_overrides JSONB NOT NULL DEFAULT '{}',
  
  -- Grace period tracking for mode transitions
  transitioning_to TEXT CHECK (transitioning_to IN ('supervised', 'assisted', 'autopilot')),
  transition_started_at TIMESTAMPTZ,
  
  -- Guardrails with spec-defined defaults (Feature 1)
  guardrails JSONB NOT NULL DEFAULT '{
    "daily_pin_limit": 5,
    "weekly_ad_spend_cap": 100,
    "monthly_ad_spend_cap": null,
    "annual_mockup_budget": 3500,
    "monthly_mockup_soft_limit": 292,
    "auto_retire_days": 7,
    "abandonment_window_hours": 1,
    "duplicate_content_days": 30
  }',
  
  -- Timezone for scheduling and digest emails
  timezone TEXT NOT NULL DEFAULT 'America/New_York',
  
  -- Setup Wizard Progress (Feature 3)
  -- Values: 'pending', 'in_progress', 'completed', 'skipped'
  setup_progress JSONB NOT NULL DEFAULT '{
    "shopify": "pending",
    "pinterest": "pending",
    "klaviyo": "pending",
    "dynamic_mockups": "pending",
    "resend": "pending",
    "design_rules": "pending",
    "operator_mode": "pending",
    "import": "pending"
  }',
  setup_completed_at TIMESTAMPTZ,
  
  -- Daily Digest Preferences (Feature 6)
  -- send_hour: 6-10 (user's timezone)
  -- frequency: 'daily', 'weekdays', 'weekly'
  digest_preferences JSONB NOT NULL DEFAULT '{
    "enabled": true,
    "send_hour": 7,
    "frequency": "daily",
    "sections": {
      "metrics": true,
      "scheduled_content": true,
      "overnight_activity": true,
      "pending_approvals": true,
      "ad_spend": true,
      "alerts": true,
      "mockup_credits": true
    }
  }',
  
  -- General notification preferences
  notification_preferences JSONB NOT NULL DEFAULT '{
    "email_alerts": true,
    "alert_delivery": "immediate",
    "retry_failure_notifications": true
  }',
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create index for user lookup
CREATE INDEX idx_user_settings_user_id ON user_settings(user_id);

-- Updated at trigger
CREATE TRIGGER user_settings_updated_at
  BEFORE UPDATE ON user_settings
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- Row Level Security
-- ============================================================================
ALTER TABLE user_settings ENABLE ROW LEVEL SECURITY;

-- Users can only see their own settings
CREATE POLICY user_settings_select ON user_settings
  FOR SELECT USING (user_id = auth.uid());

-- Users can only insert their own settings
CREATE POLICY user_settings_insert ON user_settings
  FOR INSERT WITH CHECK (user_id = auth.uid());

-- Users can only update their own settings
CREATE POLICY user_settings_update ON user_settings
  FOR UPDATE USING (user_id = auth.uid());

-- Users can only delete their own settings
CREATE POLICY user_settings_delete ON user_settings
  FOR DELETE USING (user_id = auth.uid());

-- ============================================================================
-- Auto-create settings on user creation
-- ============================================================================
CREATE OR REPLACE FUNCTION create_user_settings()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.user_settings (user_id)
  VALUES (NEW.id)
  ON CONFLICT (user_id) DO NOTHING;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION create_user_settings();

-- ============================================================================
-- Helper function to get effective mode for a module
-- ============================================================================
CREATE OR REPLACE FUNCTION get_effective_mode(
  p_user_id UUID,
  p_module TEXT DEFAULT NULL
)
RETURNS TEXT AS $$
DECLARE
  v_global_mode TEXT;
  v_module_override TEXT;
  v_result TEXT;
BEGIN
  SELECT 
    global_mode,
    module_overrides->>p_module
  INTO v_global_mode, v_module_override
  FROM user_settings
  WHERE user_id = p_user_id;
  
  -- Return module override if set, otherwise global mode
  v_result := COALESCE(v_module_override, v_global_mode, 'supervised');
  
  RETURN v_result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- Helper function to check guardrail
-- ============================================================================
CREATE OR REPLACE FUNCTION check_guardrail(
  p_user_id UUID,
  p_guardrail_key TEXT,
  p_current_value NUMERIC
)
RETURNS TABLE (
  allowed BOOLEAN,
  limit_value NUMERIC,
  remaining NUMERIC
) AS $$
DECLARE
  v_limit NUMERIC;
BEGIN
  SELECT (guardrails->>p_guardrail_key)::NUMERIC
  INTO v_limit
  FROM user_settings
  WHERE user_id = p_user_id;
  
  -- If limit is null, no restriction
  IF v_limit IS NULL THEN
    RETURN QUERY SELECT true, NULL::NUMERIC, NULL::NUMERIC;
    RETURN;
  END IF;
  
  -- Check if within limit
  RETURN QUERY SELECT 
    p_current_value < v_limit,
    v_limit,
    GREATEST(v_limit - p_current_value, 0);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### `types/database.ts` (add to existing)
```typescript
// Add these types to the existing types/database.ts file

export type OperatorMode = 'supervised' | 'assisted' | 'autopilot';

export type SetupStepStatus = 'pending' | 'in_progress' | 'completed' | 'skipped';

export interface ModuleOverrides {
  pinterest?: OperatorMode;
  design_engine?: OperatorMode;
  mockups?: OperatorMode;
  ads?: OperatorMode;
  products?: OperatorMode;
  ugc?: OperatorMode;
}

export interface Guardrails {
  daily_pin_limit: number;
  weekly_ad_spend_cap: number;
  monthly_ad_spend_cap: number | null;
  annual_mockup_budget: number;
  monthly_mockup_soft_limit: number;
  auto_retire_days: number;
  abandonment_window_hours: number;
  duplicate_content_days: number;
}

export interface SetupProgress {
  shopify: SetupStepStatus;
  pinterest: SetupStepStatus;
  klaviyo: SetupStepStatus;
  dynamic_mockups: SetupStepStatus;
  resend: SetupStepStatus;
  design_rules: SetupStepStatus;
  operator_mode: SetupStepStatus;
  import: SetupStepStatus;
}

export interface DigestSections {
  metrics: boolean;
  scheduled_content: boolean;
  overnight_activity: boolean;
  pending_approvals: boolean;
  ad_spend: boolean;
  alerts: boolean;
  mockup_credits: boolean;
}

export interface DigestPreferences {
  enabled: boolean;
  send_hour: number; // 6-10
  frequency: 'daily' | 'weekdays' | 'weekly';
  sections: DigestSections;
}

export interface NotificationPreferences {
  email_alerts: boolean;
  alert_delivery: 'immediate' | 'daily';
  retry_failure_notifications: boolean;
}

export interface UserSettings {
  id: string;
  user_id: string;
  global_mode: OperatorMode;
  module_overrides: ModuleOverrides;
  transitioning_to: OperatorMode | null;
  transition_started_at: string | null;
  guardrails: Guardrails;
  timezone: string;
  setup_progress: SetupProgress;
  setup_completed_at: string | null;
  digest_preferences: DigestPreferences;
  notification_preferences: NotificationPreferences;
  created_at: string;
  updated_at: string;
}

// Guardrail defaults as constants (matching migration)
export const GUARDRAIL_DEFAULTS: Guardrails = {
  daily_pin_limit: 5,
  weekly_ad_spend_cap: 100,
  monthly_ad_spend_cap: null,
  annual_mockup_budget: 3500,
  monthly_mockup_soft_limit: 292,
  auto_retire_days: 7,
  abandonment_window_hours: 1,
  duplicate_content_days: 30,
};
```

- **Step Dependencies**: Step 1.8
- **User Instructions**: 
  1. Create a `supabase` directory in your project root if it doesn't exist
  2. Create a `migrations` subdirectory
  3. Run `npx supabase db push` or paste the SQL into Supabase Dashboard SQL Editor

---

