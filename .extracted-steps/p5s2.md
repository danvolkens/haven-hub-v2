## Step 5.2: Implement OAuth Flow for Shopify

- **Task**: Create the complete Shopify OAuth flow including install, callback, and webhook registration.

- **Files**:

### `lib/integrations/shopify/config.ts`
```typescript
export const SHOPIFY_CONFIG = {
  clientId: process.env.SHOPIFY_CLIENT_ID!,
  clientSecret: process.env.SHOPIFY_CLIENT_SECRET!,
  scopes: [
    'read_products',
    'write_products',
    'read_orders',
    'read_customers',
    'write_customers',
    'read_inventory',
    'write_inventory',
    'read_content',
    'write_content',
  ].join(','),
  webhookTopics: [
    'orders/create',
    'orders/updated',
    'checkouts/create',
    'checkouts/update',
    'customers/create',
    'customers/update',
    'products/update',
    'app/uninstalled',
  ],
};

export function getShopifyAuthUrl(shop: string, state: string, redirectUri: string): string {
  const params = new URLSearchParams({
    client_id: SHOPIFY_CONFIG.clientId,
    scope: SHOPIFY_CONFIG.scopes,
    redirect_uri: redirectUri,
    state,
    'grant_options[]': 'per-user',
  });

  return `https://${shop}/admin/oauth/authorize?${params.toString()}`;
}

export function getShopifyApiUrl(shop: string, version = '2024-01'): string {
  return `https://${shop}/admin/api/${version}`;
}
```

### `lib/integrations/shopify/client.ts`
```typescript
import { getShopifyApiUrl } from './config';

interface ShopifyClientOptions {
  shop: string;
  accessToken: string;
}

export class ShopifyClient {
  private shop: string;
  private accessToken: string;
  private baseUrl: string;

  constructor({ shop, accessToken }: ShopifyClientOptions) {
    this.shop = shop;
    this.accessToken = accessToken;
    this.baseUrl = getShopifyApiUrl(shop);
  }

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${this.baseUrl}${endpoint}`;
    
    const response = await fetch(url, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        'X-Shopify-Access-Token': this.accessToken,
        ...options.headers,
      },
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.errors || `Shopify API error: ${response.status}`);
    }

    return response.json();
  }

  // Shop info
  async getShop() {
    return this.request<{ shop: ShopifyShop }>('/shop.json');
  }

  // Products
  async getProducts(params?: { limit?: number; since_id?: string }) {
    const query = new URLSearchParams(params as Record<string, string>);
    return this.request<{ products: ShopifyProduct[] }>(`/products.json?${query}`);
  }

  async createProduct(product: Partial<ShopifyProduct>) {
    return this.request<{ product: ShopifyProduct }>('/products.json', {
      method: 'POST',
      body: JSON.stringify({ product }),
    });
  }

  async updateProduct(id: string, product: Partial<ShopifyProduct>) {
    return this.request<{ product: ShopifyProduct }>(`/products/${id}.json`, {
      method: 'PUT',
      body: JSON.stringify({ product }),
    });
  }

  // Collections
  async getCustomCollections() {
    return this.request<{ custom_collections: ShopifyCollection[] }>(
      '/custom_collections.json'
    );
  }

  async getSmartCollections() {
    return this.request<{ smart_collections: ShopifyCollection[] }>(
      '/smart_collections.json'
    );
  }

  // Customers
  async getCustomer(id: string) {
    return this.request<{ customer: ShopifyCustomer }>(`/customers/${id}.json`);
  }

  async searchCustomers(query: string) {
    return this.request<{ customers: ShopifyCustomer[] }>(
      `/customers/search.json?query=${encodeURIComponent(query)}`
    );
  }

  // Orders
  async getOrders(params?: { status?: string; limit?: number }) {
    const query = new URLSearchParams(params as Record<string, string>);
    return this.request<{ orders: ShopifyOrder[] }>(`/orders.json?${query}`);
  }

  // Webhooks
  async getWebhooks() {
    return this.request<{ webhooks: ShopifyWebhook[] }>('/webhooks.json');
  }

  async createWebhook(topic: string, address: string) {
    return this.request<{ webhook: ShopifyWebhook }>('/webhooks.json', {
      method: 'POST',
      body: JSON.stringify({
        webhook: { topic, address, format: 'json' },
      }),
    });
  }

  async deleteWebhook(id: string) {
    return this.request(`/webhooks/${id}.json`, { method: 'DELETE' });
  }
}

// Types
export interface ShopifyShop {
  id: number;
  name: string;
  email: string;
  domain: string;
  myshopify_domain: string;
  currency: string;
  timezone: string;
}

export interface ShopifyProduct {
  id: number;
  title: string;
  body_html: string;
  vendor: string;
  product_type: string;
  status: 'active' | 'archived' | 'draft';
  tags: string;
  variants: ShopifyVariant[];
  images: ShopifyImage[];
  options: ShopifyOption[];
}

export interface ShopifyVariant {
  id: number;
  product_id: number;
  title: string;
  price: string;
  sku: string;
  inventory_quantity: number;
  option1: string | null;
  option2: string | null;
  option3: string | null;
}

export interface ShopifyImage {
  id: number;
  product_id: number;
  position: number;
  src: string;
  alt: string | null;
}

export interface ShopifyOption {
  id: number;
  product_id: number;
  name: string;
  values: string[];
}

export interface ShopifyCollection {
  id: number;
  title: string;
  handle: string;
  body_html: string;
}

export interface ShopifyCustomer {
  id: number;
  email: string;
  first_name: string;
  last_name: string;
  orders_count: number;
  total_spent: string;
  tags: string;
}

export interface ShopifyOrder {
  id: number;
  email: string;
  created_at: string;
  total_price: string;
  financial_status: string;
  fulfillment_status: string | null;
  line_items: Array<{
    id: number;
    product_id: number;
    variant_id: number;
    title: string;
    quantity: number;
    price: string;
  }>;
  customer: ShopifyCustomer;
}

export interface ShopifyWebhook {
  id: number;
  address: string;
  topic: string;
  created_at: string;
  updated_at: string;
}
```

### `app/api/integrations/shopify/install/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { getUserId } from '@/lib/auth/session';
import { getShopifyAuthUrl, SHOPIFY_CONFIG } from '@/lib/integrations/shopify/config';
import { nanoid } from 'nanoid';

export async function GET(request: NextRequest) {
  try {
    const userId = await getUserId();
    const searchParams = request.nextUrl.searchParams;
    const shop = searchParams.get('shop');

    if (!shop) {
      return NextResponse.json({ error: 'Shop parameter required' }, { status: 400 });
    }

    // Validate shop domain format
    if (!shop.match(/^[a-zA-Z0-9][a-zA-Z0-9-]*\.myshopify\.com$/)) {
      return NextResponse.json({ error: 'Invalid shop domain' }, { status: 400 });
    }

    // Generate and store state for CSRF protection
    const state = nanoid(32);
    const supabase = createServerSupabaseClient();

    // Store state in user's integration record
    await supabase
      .from('integrations')
      .upsert({
        user_id: userId,
        provider: 'shopify',
        status: 'connecting',
        metadata: { shop_domain: shop, oauth_state: state },
      });

    // Generate OAuth URL
    const redirectUri = `${process.env.NEXT_PUBLIC_APP_URL}/api/integrations/shopify/callback`;
    const authUrl = getShopifyAuthUrl(shop, state, redirectUri);

    return NextResponse.redirect(authUrl);
  } catch (error) {
    console.error('Shopify install error:', error);
    return NextResponse.redirect(
      `${process.env.NEXT_PUBLIC_APP_URL}/dashboard/settings/integrations?error=shopify_install_failed`
    );
  }
}
```

### `app/api/integrations/shopify/callback/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { getAdminClient } from '@/lib/supabase/admin';
import { getUserId } from '@/lib/auth/session';
import { SHOPIFY_CONFIG } from '@/lib/integrations/shopify/config';
import { ShopifyClient } from '@/lib/integrations/shopify/client';
import crypto from 'crypto';

export async function GET(request: NextRequest) {
  try {
    const userId = await getUserId();
    const searchParams = request.nextUrl.searchParams;
    
    const shop = searchParams.get('shop');
    const code = searchParams.get('code');
    const state = searchParams.get('state');
    const hmac = searchParams.get('hmac');

    if (!shop || !code || !state) {
      throw new Error('Missing required parameters');
    }

    // Verify HMAC
    const queryParams = new URLSearchParams(searchParams);
    queryParams.delete('hmac');
    queryParams.sort();
    
    const message = queryParams.toString();
    const generatedHmac = crypto
      .createHmac('sha256', SHOPIFY_CONFIG.clientSecret)
      .update(message)
      .digest('hex');

    if (hmac !== generatedHmac) {
      throw new Error('HMAC validation failed');
    }

    // Verify state matches stored state
    const supabase = createServerSupabaseClient();
    const { data: integration } = await supabase
      .from('integrations')
      .select('metadata')
      .eq('user_id', userId)
      .eq('provider', 'shopify')
      .single();

    if (!integration || integration.metadata.oauth_state !== state) {
      throw new Error('Invalid state parameter');
    }

    // Exchange code for access token
    const tokenResponse = await fetch(`https://${shop}/admin/oauth/access_token`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        client_id: SHOPIFY_CONFIG.clientId,
        client_secret: SHOPIFY_CONFIG.clientSecret,
        code,
      }),
    });

    if (!tokenResponse.ok) {
      throw new Error('Failed to exchange code for token');
    }

    const { access_token, scope } = await tokenResponse.json();

    // Get shop info
    const client = new ShopifyClient({ shop, accessToken: access_token });
    const { shop: shopInfo } = await client.getShop();

    // Store access token securely in vault
    const adminClient = getAdminClient();
    await adminClient.rpc('store_credential', {
      p_user_id: userId,
      p_provider: 'shopify',
      p_credential_type: 'access_token',
      p_credential_value: access_token,
    });

    // Update integration record
    await supabase
      .from('integrations')
      .update({
        status: 'connected',
        metadata: {
          shop_domain: shop,
          shop_name: shopInfo.name,
          access_scopes: scope.split(','),
        },
        connected_at: new Date().toISOString(),
        last_error: null,
        last_error_at: null,
      })
      .eq('user_id', userId)
      .eq('provider', 'shopify');

    // Register webhooks
    await registerShopifyWebhooks(userId, shop, access_token);

    // Update setup progress
    await supabase
      .from('user_settings')
      .update({
        setup_progress: supabase.sql`jsonb_set(setup_progress, '{shopify}', '"completed"')`,
      })
      .eq('user_id', userId);

    // Log activity
    await supabase.rpc('log_activity', {
      p_user_id: userId,
      p_action_type: 'integration_connected',
      p_details: { provider: 'shopify', shop },
      p_executed: true,
      p_module: 'settings',
    });

    return NextResponse.redirect(
      `${process.env.NEXT_PUBLIC_APP_URL}/dashboard/settings/integrations?success=shopify_connected`
    );
  } catch (error) {
    console.error('Shopify callback error:', error);
    return NextResponse.redirect(
      `${process.env.NEXT_PUBLIC_APP_URL}/dashboard/settings/integrations?error=shopify_callback_failed`
    );
  }
}

async function registerShopifyWebhooks(
  userId: string,
  shop: string,
  accessToken: string
) {
  const client = new ShopifyClient({ shop, accessToken });
  const supabase = createServerSupabaseClient();
  const baseUrl = process.env.NEXT_PUBLIC_APP_URL;

  for (const topic of SHOPIFY_CONFIG.webhookTopics) {
    try {
      const address = `${baseUrl}/api/webhooks/shopify?topic=${topic}`;
      const { webhook } = await client.createWebhook(topic, address);

      await supabase.from('shopify_webhooks').insert({
        user_id: userId,
        shopify_webhook_id: String(webhook.id),
        topic,
        address,
      });
    } catch (error) {
      console.error(`Failed to register webhook ${topic}:`, error);
    }
  }
}
```

- **Step Dependencies**: Step 5.1
- **User Instructions**: 
  1. Create Shopify Partner account and app
  2. Add SHOPIFY_CLIENT_ID and SHOPIFY_CLIENT_SECRET to .env.local
  3. Set allowed redirect URLs in Shopify Partner Dashboard

---

