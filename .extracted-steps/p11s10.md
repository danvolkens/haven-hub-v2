## Step 23.1: Create Digest Database Schema and Service

- **Task**: Create the database schema and service for daily digest notifications.

- **Files**:

### `supabase/migrations/020_digest.sql`
```sql
-- ============================================================================
-- Migration: 020_digest
-- Description: Daily digest configuration and history
-- Feature: 23 (Daily Digest)
-- ============================================================================

-- ============================================================================
-- Digest Preferences Table
-- ============================================================================
CREATE TABLE digest_preferences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL UNIQUE,
  
  -- Delivery settings
  is_enabled BOOLEAN NOT NULL DEFAULT true,
  delivery_time TIME NOT NULL DEFAULT '08:00',
  timezone TEXT NOT NULL DEFAULT 'America/New_York',
  delivery_method TEXT NOT NULL DEFAULT 'email' CHECK (delivery_method IN ('email', 'app', 'both')),
  
  -- Content preferences
  include_insights BOOLEAN NOT NULL DEFAULT true,
  include_performance BOOLEAN NOT NULL DEFAULT true,
  include_approvals BOOLEAN NOT NULL DEFAULT true,
  include_tasks BOOLEAN NOT NULL DEFAULT true,
  include_recommendations BOOLEAN NOT NULL DEFAULT true,
  
  -- Frequency
  frequency TEXT NOT NULL DEFAULT 'daily' CHECK (frequency IN ('daily', 'weekdays', 'weekly')),
  weekly_day INTEGER DEFAULT 1, -- For weekly: 0=Sun, 1=Mon, etc.
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================================================
-- Digest History Table
-- ============================================================================
CREATE TABLE digest_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  
  -- Delivery
  delivered_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  delivery_method TEXT NOT NULL,
  
  -- Content summary
  content JSONB NOT NULL DEFAULT '{}',
  -- {
  --   insights_count: number,
  --   pending_approvals: number,
  --   pins_published: number,
  --   orders_received: number,
  --   revenue: number,
  --   recommendations_count: number,
  --   highlights: string[]
  -- }
  
  -- Engagement
  opened_at TIMESTAMPTZ,
  clicked_at TIMESTAMPTZ,
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================================================
-- Indexes
-- ============================================================================
CREATE INDEX idx_digest_prefs_user ON digest_preferences(user_id);
CREATE INDEX idx_digest_history_user ON digest_history(user_id, delivered_at);

-- ============================================================================
-- Row Level Security
-- ============================================================================
ALTER TABLE digest_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE digest_history ENABLE ROW LEVEL SECURITY;

CREATE POLICY digest_prefs_all ON digest_preferences FOR ALL USING (user_id = auth.uid());
CREATE POLICY digest_history_all ON digest_history FOR ALL USING (user_id = auth.uid());

CREATE TRIGGER digest_prefs_updated_at BEFORE UPDATE ON digest_preferences
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### `lib/digest/digest-service.ts`
```typescript
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { getAdminClient } from '@/lib/supabase/admin';
import { getActiveInsights, getPendingRecommendations } from '@/lib/intelligence/intelligence-service';

interface DigestContent {
  insights_count: number;
  pending_approvals: number;
  pins_published: number;
  pins_scheduled: number;
  orders_received: number;
  revenue: number;
  new_leads: number;
  recommendations_count: number;
  highlights: string[];
  top_insight?: {
    title: string;
    summary: string;
    priority: string;
  };
  at_risk_customers: number;
  upcoming_campaigns: number;
}

export async function generateDailyDigest(userId: string): Promise<DigestContent> {
  const supabase = createServerSupabaseClient();
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  const yesterdayStr = yesterday.toISOString();

  // Get insights
  const insights = await getActiveInsights(userId, { limit: 10 });
  const recommendations = await getPendingRecommendations(userId, { limit: 5 });

  // Get pending approvals
  const { count: pendingApprovals } = await supabase
    .from('approval_items')
    .select('*', { count: 'exact', head: true })
    .eq('user_id', userId)
    .eq('status', 'pending');

  // Get pins published yesterday
  const { count: pinsPublished } = await supabase
    .from('pins')
    .select('*', { count: 'exact', head: true })
    .eq('user_id', userId)
    .eq('status', 'published')
    .gte('published_at', yesterdayStr);

  // Get pins scheduled
  const { count: pinsScheduled } = await supabase
    .from('pins')
    .select('*', { count: 'exact', head: true })
    .eq('user_id', userId)
    .eq('status', 'scheduled');

  // Get orders from yesterday
  const { data: orders } = await supabase
    .from('customer_orders')
    .select('total')
    .eq('user_id', userId)
    .gte('ordered_at', yesterdayStr);

  const ordersReceived = orders?.length || 0;
  const revenue = orders?.reduce((sum, o) => sum + o.total, 0) || 0;

  // Get new leads
  const { count: newLeads } = await supabase
    .from('leads')
    .select('*', { count: 'exact', head: true })
    .eq('user_id', userId)
    .gte('created_at', yesterdayStr);

  // Get at-risk customers
  const { count: atRiskCustomers } = await supabase
    .from('customers')
    .select('*', { count: 'exact', head: true })
    .eq('user_id', userId)
    .in('journey_stage', ['at_risk', 'churned']);

  // Get upcoming campaigns
  const { count: upcomingCampaigns } = await supabase
    .from('campaigns')
    .select('*', { count: 'exact', head: true })
    .eq('user_id', userId)
    .eq('status', 'scheduled')
    .gte('start_date', new Date().toISOString().split('T')[0]);

  // Generate highlights
  const highlights: string[] = [];

  if (ordersReceived > 0) {
    highlights.push(`ðŸ’° ${ordersReceived} new order${ordersReceived > 1 ? 's' : ''} ($${revenue.toFixed(2)} revenue)`);
  }

  if (pinsPublished && pinsPublished > 0) {
    highlights.push(`ðŸ“Œ ${pinsPublished} pin${pinsPublished > 1 ? 's' : ''} published yesterday`);
  }

  if (newLeads && newLeads > 0) {
    highlights.push(`âœ¨ ${newLeads} new lead${newLeads > 1 ? 's' : ''} captured`);
  }

  if (atRiskCustomers && atRiskCustomers > 5) {
    highlights.push(`âš ï¸ ${atRiskCustomers} customers at risk of churning`);
  }

  // Get top insight
  const topInsight = insights.find((i) => i.priority === 'critical' || i.priority === 'high');

  return {
    insights_count: insights.length,
    pending_approvals: pendingApprovals || 0,
    pins_published: pinsPublished || 0,
    pins_scheduled: pinsScheduled || 0,
    orders_received: ordersReceived,
    revenue,
    new_leads: newLeads || 0,
    recommendations_count: recommendations.length,
    highlights,
    top_insight: topInsight ? {
      title: topInsight.title,
      summary: topInsight.summary,
      priority: topInsight.priority,
    } : undefined,
    at_risk_customers: atRiskCustomers || 0,
    upcoming_campaigns: upcomingCampaigns || 0,
  };
}

export async function sendDigest(userId: string): Promise<{ success: boolean; error?: string }> {
  const supabase = createServerSupabaseClient();
  const adminClient = getAdminClient();

  try {
    // Get user preferences
    const { data: prefs } = await supabase
      .from('digest_preferences')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (!prefs?.is_enabled) {
      return { success: false, error: 'Digest disabled' };
    }

    // Generate content
    const content = await generateDailyDigest(userId);

    // Get user email
    const { data: { user } } = await adminClient.auth.admin.getUserById(userId);
    if (!user?.email) {
      return { success: false, error: 'User email not found' };
    }

    // Send via configured method
    if (prefs.delivery_method === 'email' || prefs.delivery_method === 'both') {
      await sendDigestEmail(user.email, content);
    }

    // Record in history
    await supabase.from('digest_history').insert({
      user_id: userId,
      delivery_method: prefs.delivery_method,
      content,
    });

    return { success: true };
  } catch (error) {
    console.error('Send digest error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

async function sendDigestEmail(email: string, content: DigestContent): Promise<void> {
  // This would integrate with Resend or Klaviyo
  // For now, just log
  console.log(`Sending digest to ${email}:`, content);
  
  // TODO: Implement actual email sending
  // const resend = new Resend(process.env.RESEND_API_KEY);
  // await resend.emails.send({
  //   from: 'Haven Hub <digest@havenhub.com>',
  //   to: email,
  //   subject: 'Your Daily Haven Hub Digest',
  //   html: generateDigestHtml(content),
  // });
}

export async function processScheduledDigests(): Promise<{ sent: number; errors: number }> {
  const supabase = createServerSupabaseClient();
  const now = new Date();
  const currentHour = now.getHours();
  const currentMinute = now.getMinutes();
  const dayOfWeek = now.getDay();
  const isWeekday = dayOfWeek >= 1 && dayOfWeek <= 5;

  // Get all users who should receive digest now
  const { data: preferences } = await supabase
    .from('digest_preferences')
    .select('user_id, frequency, weekly_day, delivery_time')
    .eq('is_enabled', true);

  if (!preferences) {
    return { sent: 0, errors: 0 };
  }

  let sent = 0;
  let errors = 0;

  for (const pref of preferences) {
    // Check if it's time to send
    const [prefHour, prefMinute] = pref.delivery_time.split(':').map(Number);
    
    // Allow 5-minute window
    if (Math.abs(currentHour * 60 + currentMinute - prefHour * 60 - prefMinute) > 5) {
      continue;
    }

    // Check frequency
    if (pref.frequency === 'weekdays' && !isWeekday) {
      continue;
    }
    if (pref.frequency === 'weekly' && dayOfWeek !== pref.weekly_day) {
      continue;
    }

    const result = await sendDigest(pref.user_id);
    if (result.success) {
      sent++;
    } else {
      errors++;
    }
  }

  return { sent, errors };
}
```

### `trigger/daily-digest.ts`
```typescript
import { schedules } from '@trigger.dev/sdk/v3';
import { processScheduledDigests } from '@/lib/digest/digest-service';
import { runDailyAnalysis } from '@/lib/intelligence/intelligence-service';
import { createClient } from '@supabase/supabase-js';

export const dailyDigestTask = schedules.task({
  id: 'daily-digest',
  cron: '0 * * * *', // Run every hour to catch different timezones
  
  run: async () => {
    const result = await processScheduledDigests();
    return {
      sent: result.sent,
      errors: result.errors,
    };
  },
});

export const dailyAnalysisTask = schedules.task({
  id: 'daily-analysis',
  cron: '0 4 * * *', // Run at 4 AM UTC
  
  run: async () => {
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    );

    // Get all users
    const { data: users } = await supabase
      .from('user_settings')
      .select('user_id');

    if (!users) return { processed: 0 };

    let processed = 0;
    for (const user of users) {
      try {
        await runDailyAnalysis(user.user_id);
        processed++;
      } catch (error) {
        console.error(`Analysis failed for user ${user.user_id}:`, error);
      }
    }

    return { processed };
  },
});
```

- **Step Dependencies**: Step 22.2
- **User Instructions**: Run migration, configure cron jobs

---

# Phase 24: Polish & Optimization

