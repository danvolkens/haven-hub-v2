## Step 3.2: Create Operator Mode API Endpoints

- **Task**: Implement API routes for fetching and updating operator mode settings.

- **Files**:

### `app/api/settings/operator-mode/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { getUserId } from '@/lib/auth/session';
import { invalidateUserCache } from '@/lib/cache/cache-utils';

const updateModeSchema = z.object({
  mode: z.enum(['supervised', 'assisted', 'autopilot']),
});

export async function GET() {
  try {
    const supabase = createServerSupabaseClient();
    const userId = await getUserId();
    
    const { data, error } = await supabase
      .from('user_settings')
      .select('global_mode, module_overrides, transitioning_to, transition_started_at, guardrails')
      .eq('user_id', userId)
      .single();
    
    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Internal error' },
      { status: 500 }
    );
  }
}

export async function PATCH(request: NextRequest) {
  try {
    const supabase = createServerSupabaseClient();
    const userId = await getUserId();
    const body = await request.json();
    
    const { mode } = updateModeSchema.parse(body);
    
    // Check for in-flight operations
    const { count: pendingCount } = await supabase
      .from('approval_items')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId)
      .eq('status', 'processing');
    
    const { count: publishingPins } = await supabase
      .from('pins')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId)
      .eq('status', 'publishing');
    
    const totalPending = (pendingCount || 0) + (publishingPins || 0);
    
    if (totalPending > 0) {
      // Start grace period
      const { error } = await supabase
        .from('user_settings')
        .update({
          transitioning_to: mode,
          transition_started_at: new Date().toISOString(),
        })
        .eq('user_id', userId);
      
      if (error) {
        return NextResponse.json({ error: error.message }, { status: 500 });
      }
      
      // Log activity
      await supabase.rpc('log_activity', {
        p_user_id: userId,
        p_action_type: 'mode_change',
        p_details: { from: 'current', to: mode, gracePeriod: true },
        p_executed: false,
        p_module: 'settings',
      });
      
      return NextResponse.json({
        success: true,
        gracePeriod: true,
        pendingCount: totalPending,
      });
    }
    
    // Get current mode for logging
    const { data: currentSettings } = await supabase
      .from('user_settings')
      .select('global_mode')
      .eq('user_id', userId)
      .single();
    
    // Immediate switch
    const { error } = await supabase
      .from('user_settings')
      .update({
        global_mode: mode,
        transitioning_to: null,
        transition_started_at: null,
      })
      .eq('user_id', userId);
    
    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    
    // Log activity
    await supabase.rpc('log_activity', {
      p_user_id: userId,
      p_action_type: 'mode_change',
      p_details: { gracePeriod: false },
      p_executed: true,
      p_module: 'settings',
      p_previous_value: { mode: currentSettings?.global_mode },
      p_new_value: { mode },
    });
    
    // Invalidate cache
    await invalidateUserCache(userId);
    
    return NextResponse.json({
      success: true,
      gracePeriod: false,
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: 'Invalid mode value' }, { status: 400 });
    }
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Internal error' },
      { status: 500 }
    );
  }
}
```

### `app/api/settings/operator-mode/module/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { getUserId } from '@/lib/auth/session';
import { invalidateUserCache } from '@/lib/cache/cache-utils';

const updateModuleSchema = z.object({
  module: z.string(),
  mode: z.enum(['supervised', 'assisted', 'autopilot']).nullable(),
});

export async function PATCH(request: NextRequest) {
  try {
    const supabase = createServerSupabaseClient();
    const userId = await getUserId();
    const body = await request.json();
    
    const { module, mode } = updateModuleSchema.parse(body);
    
    // Get current overrides
    const { data: settings, error: fetchError } = await supabase
      .from('user_settings')
      .select('module_overrides')
      .eq('user_id', userId)
      .single();
    
    if (fetchError) {
      return NextResponse.json({ error: fetchError.message }, { status: 500 });
    }
    
    const currentOverrides = settings?.module_overrides || {};
    const previousValue = currentOverrides[module];
    
    // Update overrides
    let newOverrides: Record<string, string | null>;
    if (mode === null) {
      // Remove override (use global mode)
      const { [module]: _, ...rest } = currentOverrides;
      newOverrides = rest;
    } else {
      newOverrides = { ...currentOverrides, [module]: mode };
    }
    
    const { error } = await supabase
      .from('user_settings')
      .update({ module_overrides: newOverrides })
      .eq('user_id', userId);
    
    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    
    // Log activity
    await supabase.rpc('log_activity', {
      p_user_id: userId,
      p_action_type: 'mode_change',
      p_details: { module, isModuleOverride: true },
      p_executed: true,
      p_module: 'settings',
      p_previous_value: previousValue ? { [module]: previousValue } : null,
      p_new_value: mode ? { [module]: mode } : null,
    });
    
    // Invalidate cache
    await invalidateUserCache(userId);
    
    return NextResponse.json({ success: true });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: 'Invalid request body' }, { status: 400 });
    }
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Internal error' },
      { status: 500 }
    );
  }
}
```

### `app/api/settings/guardrails/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { getUserId } from '@/lib/auth/session';
import { invalidateUserCache } from '@/lib/cache/cache-utils';
import type { Guardrails } from '@/types/database';

// Validation ranges per spec
const guardrailRanges: Record<keyof Guardrails, { min: number; max: number } | null> = {
  daily_pin_limit: { min: 1, max: 25 },
  weekly_ad_spend_cap: { min: 0, max: 10000 },
  monthly_ad_spend_cap: { min: 0, max: 50000 },
  annual_mockup_budget: { min: 100, max: 10000 },
  monthly_mockup_soft_limit: { min: 10, max: 1000 },
  auto_retire_days: { min: 3, max: 30 },
  abandonment_window_hours: { min: 1, max: 24 },
  duplicate_content_days: { min: 7, max: 90 },
};

const updateGuardrailSchema = z.object({
  key: z.string(),
  value: z.number().nullable(),
});

export async function GET() {
  try {
    const supabase = createServerSupabaseClient();
    const userId = await getUserId();
    
    const { data, error } = await supabase
      .from('user_settings')
      .select('guardrails')
      .eq('user_id', userId)
      .single();
    
    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    
    return NextResponse.json(data?.guardrails);
  } catch (error) {
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Internal error' },
      { status: 500 }
    );
  }
}

export async function PATCH(request: NextRequest) {
  try {
    const supabase = createServerSupabaseClient();
    const userId = await getUserId();
    const body = await request.json();
    
    const { key, value } = updateGuardrailSchema.parse(body);
    
    // Validate key is a valid guardrail
    if (!(key in guardrailRanges)) {
      return NextResponse.json({ error: 'Invalid guardrail key' }, { status: 400 });
    }
    
    // Validate value is within range (if not null)
    if (value !== null) {
      const range = guardrailRanges[key as keyof Guardrails];
      if (range && (value < range.min || value > range.max)) {
        return NextResponse.json(
          { error: `Value must be between ${range.min} and ${range.max}` },
          { status: 400 }
        );
      }
    }
    
    // Get current guardrails
    const { data: settings, error: fetchError } = await supabase
      .from('user_settings')
      .select('guardrails')
      .eq('user_id', userId)
      .single();
    
    if (fetchError) {
      return NextResponse.json({ error: fetchError.message }, { status: 500 });
    }
    
    const currentGuardrails = settings?.guardrails as Guardrails;
    const previousValue = currentGuardrails[key as keyof Guardrails];
    
    // Update guardrails
    const newGuardrails = { ...currentGuardrails, [key]: value };
    
    const { error } = await supabase
      .from('user_settings')
      .update({ guardrails: newGuardrails })
      .eq('user_id', userId);
    
    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    
    // Log activity
    await supabase.rpc('log_activity', {
      p_user_id: userId,
      p_action_type: 'guardrail_update',
      p_details: { guardrailKey: key },
      p_executed: true,
      p_module: 'settings',
      p_previous_value: { [key]: previousValue },
      p_new_value: { [key]: value },
    });
    
    // Invalidate cache
    await invalidateUserCache(userId);
    
    return NextResponse.json({ success: true });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: 'Invalid request body' }, { status: 400 });
    }
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Internal error' },
      { status: 500 }
    );
  }
}
```

### `app/api/settings/operator-mode/grace-period/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { getUserId } from '@/lib/auth/session';
import { invalidateUserCache } from '@/lib/cache/cache-utils';

const gracePeriodActionSchema = z.object({
  action: z.enum(['complete', 'cancel']),
});

export async function GET() {
  try {
    const supabase = createServerSupabaseClient();
    const userId = await getUserId();
    
    const { data, error } = await supabase
      .from('user_settings')
      .select('global_mode, transitioning_to, transition_started_at')
      .eq('user_id', userId)
      .single();
    
    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    
    // Count pending operations
    const { count: pendingApprovals } = await supabase
      .from('approval_items')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId)
      .eq('status', 'processing');
    
    const { count: publishingPins } = await supabase
      .from('pins')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId)
      .eq('status', 'publishing');
    
    return NextResponse.json({
      isActive: !!data?.transitioning_to,
      currentMode: data?.global_mode,
      targetMode: data?.transitioning_to,
      startedAt: data?.transition_started_at,
      pendingCount: (pendingApprovals || 0) + (publishingPins || 0),
    });
  } catch (error) {
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Internal error' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const supabase = createServerSupabaseClient();
    const userId = await getUserId();
    const body = await request.json();
    
    const { action } = gracePeriodActionSchema.parse(body);
    
    // Get current state
    const { data: settings, error: fetchError } = await supabase
      .from('user_settings')
      .select('global_mode, transitioning_to')
      .eq('user_id', userId)
      .single();
    
    if (fetchError || !settings) {
      return NextResponse.json({ error: 'Settings not found' }, { status: 404 });
    }
    
    if (!settings.transitioning_to) {
      return NextResponse.json({ error: 'No active grace period' }, { status: 400 });
    }
    
    if (action === 'complete') {
      // Force complete: switch to target mode
      const { error } = await supabase
        .from('user_settings')
        .update({
          global_mode: settings.transitioning_to,
          transitioning_to: null,
          transition_started_at: null,
        })
        .eq('user_id', userId);
      
      if (error) {
        return NextResponse.json({ error: error.message }, { status: 500 });
      }
      
      // Log activity
      await supabase.rpc('log_activity', {
        p_user_id: userId,
        p_action_type: 'mode_change',
        p_details: { forced: true, gracePeriod: true },
        p_executed: true,
        p_module: 'settings',
        p_previous_value: { mode: settings.global_mode },
        p_new_value: { mode: settings.transitioning_to },
      });
    } else {
      // Cancel: clear transition state
      const { error } = await supabase
        .from('user_settings')
        .update({
          transitioning_to: null,
          transition_started_at: null,
        })
        .eq('user_id', userId);
      
      if (error) {
        return NextResponse.json({ error: error.message }, { status: 500 });
      }
      
      // Log cancellation
      await supabase.rpc('log_activity', {
        p_user_id: userId,
        p_action_type: 'mode_change',
        p_details: { cancelled: true, targetWas: settings.transitioning_to },
        p_executed: false,
        p_module: 'settings',
      });
    }
    
    // Invalidate cache
    await invalidateUserCache(userId);
    
    return NextResponse.json({ success: true, action });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: 'Invalid action' }, { status: 400 });
    }
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Internal error' },
      { status: 500 }
    );
  }
}
```

- **Step Dependencies**: Step 3.1
- **User Instructions**: None

---

*[Continuing with Steps 3.3-3.6 (Operator Mode UI) and Phase 4 (Approval Queue)...]*

---

**Part 3 Summary**

This part covers:
- Step 2.4: Cloudflare R2 storage with complete upload/download utilities
- Step 2.5: Trigger.dev configuration and job definitions
- Step 2.6: All Vercel cron jobs with real implementations
- Step 3.1: Operator Mode context with full React Query integration
- Step 3.2: Complete API routes for operator mode management

**Next: Part 4 will complete Phase 3 (Steps 3.3-3.6: Operator Mode UI) and all of Phase 4 (Approval Queue)**
