## Step 14.2: Implement Lead Capture Service

- **Task**: Create the service for handling lead capture and Klaviyo sync.

- **Files**:

### `lib/leads/lead-service.ts`
```typescript
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { getAdminClient } from '@/lib/supabase/admin';
import { syncLeadToKlaviyo } from '@/lib/integrations/klaviyo/lead-sync';
import type { Lead, FormSubmission, CreateLandingPageRequest, LandingPage } from '@/types/leads';

interface LeadCaptureResult {
  success: boolean;
  lead?: Lead;
  error?: string;
}

export async function createLandingPage(
  userId: string,
  request: CreateLandingPageRequest
): Promise<{ success: boolean; page?: LandingPage; error?: string }> {
  const supabase = createServerSupabaseClient();

  try {
    // Validate slug uniqueness
    const { data: existing } = await supabase
      .from('landing_pages')
      .select('id')
      .eq('user_id', userId)
      .eq('slug', request.slug)
      .single();

    if (existing) {
      return { success: false, error: 'Slug already exists' };
    }

    const { data: page, error } = await supabase
      .from('landing_pages')
      .insert({
        user_id: userId,
        slug: request.slug,
        name: request.name,
        type: request.type,
        headline: request.headline,
        subheadline: request.subheadline,
        body_content: request.bodyContent,
        lead_magnet_type: request.leadMagnetType,
        lead_magnet_title: request.leadMagnetTitle,
        collection: request.collection,
        form_fields: request.formFields || [
          { name: 'email', type: 'email', label: 'Email', required: true },
          { name: 'first_name', type: 'text', label: 'First Name', required: false },
        ],
        klaviyo_list_id: request.klaviyoListId,
        klaviyo_tags: request.klaviyoTags || [],
        status: 'draft',
      })
      .select()
      .single();

    if (error) {
      throw new Error(error.message);
    }

    return { success: true, page: page as LandingPage };
  } catch (error) {
    console.error('Landing page creation error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

export async function processFormSubmission(
  submissionId: string
): Promise<LeadCaptureResult> {
  const supabase = createServerSupabaseClient();

  try {
    // Process submission and create/update lead
    const { data: leadId, error } = await supabase.rpc('process_form_submission', {
      p_submission_id: submissionId,
    });

    if (error) {
      throw new Error(error.message);
    }

    // Get the created lead
    const { data: lead } = await supabase
      .from('leads')
      .select('*, landing_page:landing_pages(*)')
      .eq('id', leadId)
      .single();

    if (!lead) {
      throw new Error('Lead not found after processing');
    }

    // Sync to Klaviyo
    if (lead.landing_page?.klaviyo_list_id) {
      await syncLeadToKlaviyo(lead.user_id, lead as Lead, {
        listId: lead.landing_page.klaviyo_list_id,
        tags: lead.landing_page.klaviyo_tags || [],
      });
    }

    // Log activity
    await supabase.rpc('log_activity', {
      p_user_id: lead.user_id,
      p_action_type: 'lead_captured',
      p_details: {
        leadId: lead.id,
        email: lead.email,
        source: lead.source,
        landingPageId: lead.landing_page_id,
      },
      p_executed: true,
      p_module: 'leads',
      p_reference_id: lead.id,
      p_reference_table: 'leads',
    });

    return { success: true, lead: lead as Lead };
  } catch (error) {
    console.error('Form submission processing error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

export async function captureLead(
  userId: string,
  landingPageId: string,
  data: Record<string, string>,
  metadata?: {
    ipAddress?: string;
    userAgent?: string;
    utmSource?: string;
    utmMedium?: string;
    utmCampaign?: string;
    utmContent?: string;
    referrer?: string;
  }
): Promise<LeadCaptureResult> {
  const supabase = createServerSupabaseClient();

  try {
    // Create form submission
    const { data: submission, error: submissionError } = await supabase
      .from('form_submissions')
      .insert({
        user_id: userId,
        landing_page_id: landingPageId,
        data,
        ip_address: metadata?.ipAddress,
        user_agent: metadata?.userAgent,
      })
      .select()
      .single();

    if (submissionError) {
      throw new Error(submissionError.message);
    }

    // Process the submission
    return processFormSubmission(submission.id);
  } catch (error) {
    console.error('Lead capture error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

export async function convertLeadToCustomer(
  userId: string,
  leadId: string,
  shopifyCustomerId: string,
  orderId?: string
): Promise<{ success: boolean; error?: string }> {
  const supabase = createServerSupabaseClient();

  try {
    const { error } = await supabase
      .from('leads')
      .update({
        status: 'customer',
        shopify_customer_id: shopifyCustomerId,
        converted_at: new Date().toISOString(),
        first_order_id: orderId,
      })
      .eq('id', leadId)
      .eq('user_id', userId);

    if (error) {
      throw new Error(error.message);
    }

    // Log activity
    await supabase.rpc('log_activity', {
      p_user_id: userId,
      p_action_type: 'lead_converted',
      p_details: { leadId, shopifyCustomerId, orderId },
      p_executed: true,
      p_module: 'leads',
      p_reference_id: leadId,
      p_reference_table: 'leads',
    });

    return { success: true };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}
```

### `lib/integrations/klaviyo/lead-sync.ts`
```typescript
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { getAdminClient } from '@/lib/supabase/admin';
import type { Lead } from '@/types/leads';

interface KlaviyoSyncOptions {
  listId: string;
  tags?: string[];
}

export async function syncLeadToKlaviyo(
  userId: string,
  lead: Lead,
  options: KlaviyoSyncOptions
): Promise<{ success: boolean; profileId?: string; error?: string }> {
  const adminClient = getAdminClient();
  const supabase = createServerSupabaseClient();

  try {
    // Get Klaviyo API key
    const apiKey = await adminClient.rpc('get_credential', {
      p_user_id: userId,
      p_provider: 'klaviyo',
      p_credential_type: 'api_key',
    });

    if (!apiKey.data) {
      throw new Error('Klaviyo not connected');
    }

    // Create or update profile in Klaviyo
    const profileResponse = await fetch('https://a.klaviyo.com/api/profiles/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Klaviyo-API-Key ${apiKey.data}`,
        'revision': '2024-02-15',
      },
      body: JSON.stringify({
        data: {
          type: 'profile',
          attributes: {
            email: lead.email,
            first_name: lead.first_name,
            last_name: lead.last_name,
            phone_number: lead.phone,
            properties: {
              source: lead.source,
              recommended_collection: lead.recommended_collection,
              quiz_results: lead.quiz_results,
              utm_source: lead.utm_source,
              utm_medium: lead.utm_medium,
              utm_campaign: lead.utm_campaign,
            },
          },
        },
      }),
    });

    if (!profileResponse.ok) {
      const error = await profileResponse.json();
      throw new Error(error.errors?.[0]?.detail || 'Failed to create Klaviyo profile');
    }

    const profile = await profileResponse.json();
    const profileId = profile.data.id;

    // Subscribe to list
    await fetch('https://a.klaviyo.com/api/list-relationships/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Klaviyo-API-Key ${apiKey.data}`,
        'revision': '2024-02-15',
      },
      body: JSON.stringify({
        data: {
          type: 'list',
          id: options.listId,
          relationships: {
            profiles: {
              data: [{ type: 'profile', id: profileId }],
            },
          },
        },
      }),
    });

    // Add tags if provided
    if (options.tags && options.tags.length > 0) {
      for (const tag of options.tags) {
        await addTagToProfile(apiKey.data, profileId, tag);
      }
    }

    // Update lead with Klaviyo profile ID
    await supabase
      .from('leads')
      .update({
        klaviyo_profile_id: profileId,
        synced_to_klaviyo_at: new Date().toISOString(),
        status: 'subscribed',
      })
      .eq('id', lead.id);

    return { success: true, profileId };
  } catch (error) {
    console.error('Klaviyo sync error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

async function addTagToProfile(apiKey: string, profileId: string, tag: string) {
  // First, get or create the tag
  const tagResponse = await fetch(`https://a.klaviyo.com/api/tags/?filter=equals(name,"${tag}")`, {
    headers: {
      'Authorization': `Klaviyo-API-Key ${apiKey}`,
      'revision': '2024-02-15',
    },
  });

  let tagId: string;

  if (tagResponse.ok) {
    const tags = await tagResponse.json();
    if (tags.data.length > 0) {
      tagId = tags.data[0].id;
    } else {
      // Create tag
      const createResponse = await fetch('https://a.klaviyo.com/api/tags/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Klaviyo-API-Key ${apiKey}`,
          'revision': '2024-02-15',
        },
        body: JSON.stringify({
          data: {
            type: 'tag',
            attributes: { name: tag },
          },
        }),
      });
      const created = await createResponse.json();
      tagId = created.data.id;
    }

    // Associate tag with profile
    await fetch(`https://a.klaviyo.com/api/tags/${tagId}/relationships/profiles/`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Klaviyo-API-Key ${apiKey}`,
        'revision': '2024-02-15',
      },
      body: JSON.stringify({
        data: [{ type: 'profile', id: profileId }],
      }),
    });
  }
}
```

- **Step Dependencies**: Step 14.1
- **User Instructions**: None

---

