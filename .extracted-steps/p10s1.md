## Step 17.1: Create Customer Journey Database Schema

- **Task**: Create database schema for tracking customer touchpoints and journey stages.

- **Files**:

### `supabase/migrations/014_customer_journey.sql`
```sql
-- ============================================================================
-- Migration: 014_customer_journey
-- Description: Customer journey tracking and touchpoints
-- Feature: 17 (Customer Journey)
-- ============================================================================

-- ============================================================================
-- Customers Table (unified view from Shopify + Leads)
-- ============================================================================
CREATE TABLE customers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  
  -- External references
  shopify_customer_id TEXT,
  lead_id UUID REFERENCES leads(id) ON DELETE SET NULL,
  klaviyo_profile_id TEXT,
  
  -- Contact info
  email TEXT NOT NULL,
  first_name TEXT,
  last_name TEXT,
  phone TEXT,
  
  -- Journey stage
  stage TEXT NOT NULL DEFAULT 'lead' CHECK (stage IN (
    'visitor',      -- Anonymous visitor
    'lead',         -- Captured email
    'prospect',     -- Engaged but not purchased
    'customer',     -- Made first purchase
    'repeat',       -- Made 2+ purchases
    'vip',          -- High value customer
    'at_risk',      -- Hasn't engaged recently
    'churned'       -- Inactive for extended period
  )),
  
  -- Stage timestamps
  became_lead_at TIMESTAMPTZ,
  became_customer_at TIMESTAMPTZ,
  became_repeat_at TIMESTAMPTZ,
  became_vip_at TIMESTAMPTZ,
  became_at_risk_at TIMESTAMPTZ,
  became_churned_at TIMESTAMPTZ,
  
  -- Engagement metrics
  total_orders INTEGER NOT NULL DEFAULT 0,
  lifetime_value NUMERIC(12,2) NOT NULL DEFAULT 0,
  average_order_value NUMERIC(10,2),
  
  -- Collection affinity
  primary_collection TEXT CHECK (primary_collection IN ('grounding', 'wholeness', 'growth')),
  collection_scores JSONB DEFAULT '{"grounding": 0, "wholeness": 0, "growth": 0}',
  
  -- Last activity
  last_email_open_at TIMESTAMPTZ,
  last_email_click_at TIMESTAMPTZ,
  last_site_visit_at TIMESTAMPTZ,
  last_purchase_at TIMESTAMPTZ,
  
  -- Communication preferences
  email_subscribed BOOLEAN NOT NULL DEFAULT true,
  sms_subscribed BOOLEAN NOT NULL DEFAULT false,
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  UNIQUE(user_id, email)
);

-- ============================================================================
-- Touchpoints Table (all customer interactions)
-- ============================================================================
CREATE TABLE touchpoints (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  customer_id UUID REFERENCES customers(id) ON DELETE CASCADE NOT NULL,
  
  -- Touchpoint details
  type TEXT NOT NULL CHECK (type IN (
    'page_view',
    'email_open',
    'email_click',
    'pin_save',
    'pin_click',
    'ad_click',
    'quiz_start',
    'quiz_complete',
    'lead_capture',
    'cart_add',
    'checkout_start',
    'checkout_abandon',
    'purchase',
    'review',
    'support_ticket'
  )),
  
  -- Source/channel
  channel TEXT NOT NULL CHECK (channel IN (
    'organic',
    'pinterest',
    'email',
    'ads',
    'direct',
    'referral',
    'social'
  )),
  
  -- Reference data
  reference_id TEXT,
  reference_type TEXT,
  
  -- Context
  metadata JSONB DEFAULT '{}',
  -- { page_url, pin_id, email_campaign_id, product_id, etc. }
  
  -- Value (for purchases)
  value NUMERIC(10,2),
  
  -- Collection (if applicable)
  collection TEXT CHECK (collection IN ('grounding', 'wholeness', 'growth')),
  
  -- Attribution
  utm_source TEXT,
  utm_medium TEXT,
  utm_campaign TEXT,
  
  occurred_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================================================
-- Journey Stage Transitions Table
-- ============================================================================
CREATE TABLE stage_transitions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  customer_id UUID REFERENCES customers(id) ON DELETE CASCADE NOT NULL,
  
  -- Transition
  from_stage TEXT NOT NULL,
  to_stage TEXT NOT NULL,
  
  -- Trigger
  trigger_type TEXT NOT NULL, -- 'purchase', 'time_based', 'engagement', 'manual'
  trigger_reference_id TEXT,
  
  transitioned_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================================================
-- Customer Segments Table
-- ============================================================================
CREATE TABLE customer_segments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  
  -- Segment definition
  name TEXT NOT NULL,
  description TEXT,
  
  -- Filter criteria
  criteria JSONB NOT NULL DEFAULT '{}',
  -- { stages: [], collections: [], min_ltv: 0, max_days_since_purchase: 90, etc. }
  
  -- Klaviyo sync
  klaviyo_segment_id TEXT,
  sync_enabled BOOLEAN NOT NULL DEFAULT false,
  last_synced_at TIMESTAMPTZ,
  
  -- Counts
  customer_count INTEGER NOT NULL DEFAULT 0,
  
  -- Status
  is_dynamic BOOLEAN NOT NULL DEFAULT true, -- Auto-update membership
  is_active BOOLEAN NOT NULL DEFAULT true,
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================================================
-- Segment Membership Table
-- ============================================================================
CREATE TABLE segment_memberships (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  segment_id UUID REFERENCES customer_segments(id) ON DELETE CASCADE NOT NULL,
  customer_id UUID REFERENCES customers(id) ON DELETE CASCADE NOT NULL,
  
  added_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  removed_at TIMESTAMPTZ,
  
  UNIQUE(segment_id, customer_id)
);

-- ============================================================================
-- Indexes
-- ============================================================================
CREATE INDEX idx_customers_user ON customers(user_id);
CREATE INDEX idx_customers_email ON customers(user_id, email);
CREATE INDEX idx_customers_stage ON customers(user_id, stage);
CREATE INDEX idx_customers_shopify ON customers(shopify_customer_id) WHERE shopify_customer_id IS NOT NULL;
CREATE INDEX idx_customers_collection ON customers(user_id, primary_collection);
CREATE INDEX idx_customers_ltv ON customers(user_id, lifetime_value DESC);

CREATE INDEX idx_touchpoints_customer ON touchpoints(customer_id);
CREATE INDEX idx_touchpoints_type ON touchpoints(user_id, type);
CREATE INDEX idx_touchpoints_channel ON touchpoints(user_id, channel);
CREATE INDEX idx_touchpoints_occurred ON touchpoints(user_id, occurred_at DESC);

CREATE INDEX idx_transitions_customer ON stage_transitions(customer_id);
CREATE INDEX idx_transitions_stage ON stage_transitions(user_id, to_stage);

CREATE INDEX idx_segments_user ON customer_segments(user_id);
CREATE INDEX idx_memberships_segment ON segment_memberships(segment_id);
CREATE INDEX idx_memberships_customer ON segment_memberships(customer_id);

-- ============================================================================
-- Row Level Security
-- ============================================================================
ALTER TABLE customers ENABLE ROW LEVEL SECURITY;
ALTER TABLE touchpoints ENABLE ROW LEVEL SECURITY;
ALTER TABLE stage_transitions ENABLE ROW LEVEL SECURITY;
ALTER TABLE customer_segments ENABLE ROW LEVEL SECURITY;
ALTER TABLE segment_memberships ENABLE ROW LEVEL SECURITY;

CREATE POLICY customers_all ON customers FOR ALL USING (user_id = auth.uid());
CREATE POLICY touchpoints_all ON touchpoints FOR ALL USING (user_id = auth.uid());
CREATE POLICY transitions_all ON stage_transitions FOR ALL USING (user_id = auth.uid());
CREATE POLICY segments_all ON customer_segments FOR ALL USING (user_id = auth.uid());

-- Memberships accessed through segment
CREATE POLICY memberships_select ON segment_memberships FOR SELECT 
  USING (EXISTS (SELECT 1 FROM customer_segments WHERE id = segment_id AND user_id = auth.uid()));

CREATE TRIGGER customers_updated_at BEFORE UPDATE ON customers
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER segments_updated_at BEFORE UPDATE ON customer_segments
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- Function: Update customer stage
-- ============================================================================
CREATE OR REPLACE FUNCTION update_customer_stage(
  p_customer_id UUID,
  p_trigger_type TEXT DEFAULT 'engagement'
)
RETURNS TEXT AS $$
DECLARE
  v_customer RECORD;
  v_new_stage TEXT;
  v_old_stage TEXT;
  v_days_since_purchase INTEGER;
  v_days_since_engagement INTEGER;
BEGIN
  SELECT * INTO v_customer FROM customers WHERE id = p_customer_id;
  
  IF NOT FOUND THEN
    RETURN NULL;
  END IF;
  
  v_old_stage := v_customer.stage;
  v_new_stage := v_old_stage;
  
  -- Calculate days since last activity
  v_days_since_purchase := EXTRACT(DAY FROM NOW() - COALESCE(v_customer.last_purchase_at, v_customer.created_at));
  v_days_since_engagement := EXTRACT(DAY FROM NOW() - GREATEST(
    COALESCE(v_customer.last_email_click_at, v_customer.created_at),
    COALESCE(v_customer.last_site_visit_at, v_customer.created_at),
    COALESCE(v_customer.last_purchase_at, v_customer.created_at)
  ));
  
  -- Determine new stage based on metrics
  IF v_customer.total_orders = 0 THEN
    IF v_customer.became_lead_at IS NOT NULL THEN
      IF v_days_since_engagement > 30 THEN
        v_new_stage := 'at_risk';
      ELSE
        v_new_stage := 'prospect';
      END IF;
    ELSE
      v_new_stage := 'visitor';
    END IF;
  ELSIF v_customer.total_orders = 1 THEN
    IF v_days_since_purchase > 90 THEN
      v_new_stage := 'at_risk';
    ELSE
      v_new_stage := 'customer';
    END IF;
  ELSIF v_customer.total_orders >= 2 THEN
    IF v_customer.lifetime_value >= 500 THEN
      v_new_stage := 'vip';
    ELSIF v_days_since_purchase > 120 THEN
      v_new_stage := 'at_risk';
    ELSE
      v_new_stage := 'repeat';
    END IF;
  END IF;
  
  -- Check for churned (180+ days no engagement)
  IF v_days_since_engagement > 180 AND v_old_stage IN ('at_risk', 'customer', 'repeat') THEN
    v_new_stage := 'churned';
  END IF;
  
  -- Update if changed
  IF v_new_stage != v_old_stage THEN
    UPDATE customers SET
      stage = v_new_stage,
      became_at_risk_at = CASE WHEN v_new_stage = 'at_risk' THEN NOW() ELSE became_at_risk_at END,
      became_churned_at = CASE WHEN v_new_stage = 'churned' THEN NOW() ELSE became_churned_at END,
      updated_at = NOW()
    WHERE id = p_customer_id;
    
    -- Record transition
    INSERT INTO stage_transitions (user_id, customer_id, from_stage, to_stage, trigger_type)
    VALUES (v_customer.user_id, p_customer_id, v_old_stage, v_new_stage, p_trigger_type);
  END IF;
  
  RETURN v_new_stage;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- Function: Calculate collection affinity
-- ============================================================================
CREATE OR REPLACE FUNCTION calculate_collection_affinity(p_customer_id UUID)
RETURNS JSONB AS $$
DECLARE
  v_scores JSONB;
  v_primary TEXT;
BEGIN
  SELECT jsonb_build_object(
    'grounding', COALESCE(SUM(CASE WHEN collection = 'grounding' THEN 
      CASE type 
        WHEN 'purchase' THEN 10
        WHEN 'cart_add' THEN 3
        WHEN 'pin_save' THEN 2
        WHEN 'pin_click' THEN 1
        ELSE 0.5
      END
    ELSE 0 END), 0),
    'wholeness', COALESCE(SUM(CASE WHEN collection = 'wholeness' THEN 
      CASE type 
        WHEN 'purchase' THEN 10
        WHEN 'cart_add' THEN 3
        WHEN 'pin_save' THEN 2
        WHEN 'pin_click' THEN 1
        ELSE 0.5
      END
    ELSE 0 END), 0),
    'growth', COALESCE(SUM(CASE WHEN collection = 'growth' THEN 
      CASE type 
        WHEN 'purchase' THEN 10
        WHEN 'cart_add' THEN 3
        WHEN 'pin_save' THEN 2
        WHEN 'pin_click' THEN 1
        ELSE 0.5
      END
    ELSE 0 END), 0)
  ) INTO v_scores
  FROM touchpoints
  WHERE customer_id = p_customer_id AND collection IS NOT NULL;
  
  -- Determine primary collection
  SELECT CASE 
    WHEN (v_scores->>'grounding')::NUMERIC >= (v_scores->>'wholeness')::NUMERIC 
      AND (v_scores->>'grounding')::NUMERIC >= (v_scores->>'growth')::NUMERIC THEN 'grounding'
    WHEN (v_scores->>'wholeness')::NUMERIC >= (v_scores->>'growth')::NUMERIC THEN 'wholeness'
    ELSE 'growth'
  END INTO v_primary;
  
  UPDATE customers SET
    collection_scores = v_scores,
    primary_collection = v_primary,
    updated_at = NOW()
  WHERE id = p_customer_id;
  
  RETURN v_scores;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### `types/customer-journey.ts`
```typescript
export interface Customer {
  id: string;
  user_id: string;
  shopify_customer_id: string | null;
  lead_id: string | null;
  klaviyo_profile_id: string | null;
  email: string;
  first_name: string | null;
  last_name: string | null;
  phone: string | null;
  stage: CustomerStage;
  became_lead_at: string | null;
  became_customer_at: string | null;
  became_repeat_at: string | null;
  became_vip_at: string | null;
  became_at_risk_at: string | null;
  became_churned_at: string | null;
  total_orders: number;
  lifetime_value: number;
  average_order_value: number | null;
  primary_collection: 'grounding' | 'wholeness' | 'growth' | null;
  collection_scores: CollectionScores;
  last_email_open_at: string | null;
  last_email_click_at: string | null;
  last_site_visit_at: string | null;
  last_purchase_at: string | null;
  email_subscribed: boolean;
  sms_subscribed: boolean;
  created_at: string;
  updated_at: string;
}

export type CustomerStage = 
  | 'visitor' 
  | 'lead' 
  | 'prospect' 
  | 'customer' 
  | 'repeat' 
  | 'vip' 
  | 'at_risk' 
  | 'churned';

export interface CollectionScores {
  grounding: number;
  wholeness: number;
  growth: number;
}

export interface Touchpoint {
  id: string;
  user_id: string;
  customer_id: string;
  type: TouchpointType;
  channel: TouchpointChannel;
  reference_id: string | null;
  reference_type: string | null;
  metadata: Record<string, unknown>;
  value: number | null;
  collection: 'grounding' | 'wholeness' | 'growth' | null;
  utm_source: string | null;
  utm_medium: string | null;
  utm_campaign: string | null;
  occurred_at: string;
  created_at: string;
}

export type TouchpointType = 
  | 'page_view'
  | 'email_open'
  | 'email_click'
  | 'pin_save'
  | 'pin_click'
  | 'ad_click'
  | 'quiz_start'
  | 'quiz_complete'
  | 'lead_capture'
  | 'cart_add'
  | 'checkout_start'
  | 'checkout_abandon'
  | 'purchase'
  | 'review'
  | 'support_ticket';

export type TouchpointChannel = 
  | 'organic'
  | 'pinterest'
  | 'email'
  | 'ads'
  | 'direct'
  | 'referral'
  | 'social';

export interface StageTransition {
  id: string;
  user_id: string;
  customer_id: string;
  from_stage: CustomerStage;
  to_stage: CustomerStage;
  trigger_type: string;
  trigger_reference_id: string | null;
  transitioned_at: string;
}

export interface CustomerSegment {
  id: string;
  user_id: string;
  name: string;
  description: string | null;
  criteria: SegmentCriteria;
  klaviyo_segment_id: string | null;
  sync_enabled: boolean;
  last_synced_at: string | null;
  customer_count: number;
  is_dynamic: boolean;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

export interface SegmentCriteria {
  stages?: CustomerStage[];
  collections?: string[];
  min_ltv?: number;
  max_ltv?: number;
  min_orders?: number;
  max_orders?: number;
  min_days_since_purchase?: number;
  max_days_since_purchase?: number;
  email_subscribed?: boolean;
}
```

- **Step Dependencies**: Step 14.1
- **User Instructions**: Run migration

---

