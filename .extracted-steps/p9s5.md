## Step 14.5: Create Popups Database Schema and API

- **Task**: Create the database and API for behavior-triggered popups.

- **Files**:

### `supabase/migrations/011a_popups.sql`
```sql
-- ============================================================================
-- Migration: 011a_popups
-- Description: Behavior-triggered popup system
-- Feature: 15 (Landing Pages & Popups)
-- ============================================================================

-- ============================================================================
-- Popups Table
-- ============================================================================
CREATE TABLE popups (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  
  -- Basic Info
  name TEXT NOT NULL,
  
  -- Trigger Configuration
  trigger_type TEXT NOT NULL CHECK (trigger_type IN (
    'exit_intent',      -- Mouse leaves viewport
    'scroll_depth',     -- Scrolled X% of page
    'time_on_page',     -- After X seconds
    'page_views',       -- After viewing X pages
    'click',            -- On element click
    'manual'            -- Triggered by code
  )),
  trigger_config JSONB NOT NULL DEFAULT '{}',
  -- exit_intent: {}
  -- scroll_depth: { percentage: 50 }
  -- time_on_page: { seconds: 30 }
  -- page_views: { count: 3 }
  -- click: { selector: '.trigger-popup' }
  
  -- Content
  content JSONB NOT NULL DEFAULT '{}',
  -- { 
  --   type: 'email_capture' | 'announcement' | 'discount' | 'quiz_cta',
  --   headline: string,
  --   body: string,
  --   image_url: string,
  --   cta_text: string,
  --   cta_link: string,
  --   discount_code: string,
  --   email_placeholder: string,
  --   success_message: string
  -- }
  
  -- Targeting
  targeting JSONB NOT NULL DEFAULT '{}',
  -- {
  --   devices: ['desktop', 'mobile', 'tablet'],
  --   url_contains: string[],
  --   url_excludes: string[],
  --   referrer_contains: string[],
  --   new_visitors_only: boolean,
  --   returning_visitors_only: boolean,
  --   exclude_if_converted: boolean
  -- }
  
  -- Frequency Capping
  frequency_cap JSONB NOT NULL DEFAULT '{"type": "once_per_session"}',
  -- {
  --   type: 'once_per_session' | 'once_per_day' | 'once_ever' | 'unlimited',
  --   max_impressions: number (for unlimited type)
  -- }
  
  -- Display Settings
  position TEXT NOT NULL DEFAULT 'center' CHECK (position IN (
    'center', 'top', 'bottom', 'top_left', 'top_right', 'bottom_left', 'bottom_right'
  )),
  animation TEXT NOT NULL DEFAULT 'fade' CHECK (animation IN (
    'fade', 'slide_up', 'slide_down', 'zoom', 'none'
  )),
  overlay_opacity INTEGER NOT NULL DEFAULT 50 CHECK (overlay_opacity >= 0 AND overlay_opacity <= 100),
  close_on_overlay_click BOOLEAN NOT NULL DEFAULT true,
  show_close_button BOOLEAN NOT NULL DEFAULT true,
  
  -- Styling
  style JSONB NOT NULL DEFAULT '{}',
  -- { background_color, text_color, accent_color, border_radius, max_width }
  
  -- Status
  status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'active', 'paused', 'archived')),
  
  -- Scheduling
  start_at TIMESTAMPTZ,
  end_at TIMESTAMPTZ,
  
  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================================================
-- Popup Analytics Table
-- ============================================================================
CREATE TABLE popup_analytics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  popup_id UUID REFERENCES popups(id) ON DELETE CASCADE NOT NULL,
  date DATE NOT NULL DEFAULT CURRENT_DATE,
  
  -- Metrics
  impressions INTEGER NOT NULL DEFAULT 0,
  closes INTEGER NOT NULL DEFAULT 0,
  conversions INTEGER NOT NULL DEFAULT 0,
  
  -- Unique counts (approximate)
  unique_impressions INTEGER NOT NULL DEFAULT 0,
  unique_conversions INTEGER NOT NULL DEFAULT 0,
  
  UNIQUE(popup_id, date)
);

-- ============================================================================
-- Popup Impressions (for deduplication)
-- ============================================================================
CREATE TABLE popup_impressions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  popup_id UUID REFERENCES popups(id) ON DELETE CASCADE NOT NULL,
  visitor_id TEXT NOT NULL,
  session_id TEXT,
  
  converted BOOLEAN NOT NULL DEFAULT false,
  converted_at TIMESTAMPTZ,
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================================================
-- Indexes
-- ============================================================================
CREATE INDEX idx_popups_user ON popups(user_id);
CREATE INDEX idx_popups_status ON popups(user_id, status);
CREATE INDEX idx_popups_active ON popups(user_id, start_at, end_at) WHERE status = 'active';

CREATE INDEX idx_popup_analytics_popup ON popup_analytics(popup_id);
CREATE INDEX idx_popup_analytics_date ON popup_analytics(popup_id, date DESC);

CREATE INDEX idx_popup_impressions_popup ON popup_impressions(popup_id);
CREATE INDEX idx_popup_impressions_visitor ON popup_impressions(popup_id, visitor_id);

-- ============================================================================
-- Row Level Security
-- ============================================================================
ALTER TABLE popups ENABLE ROW LEVEL SECURITY;
ALTER TABLE popup_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE popup_impressions ENABLE ROW LEVEL SECURITY;

CREATE POLICY popups_all ON popups FOR ALL USING (user_id = auth.uid());

CREATE POLICY popup_analytics_all ON popup_analytics FOR ALL 
  USING (popup_id IN (SELECT id FROM popups WHERE user_id = auth.uid()));

CREATE POLICY popup_impressions_all ON popup_impressions FOR ALL 
  USING (popup_id IN (SELECT id FROM popups WHERE user_id = auth.uid()));

-- ============================================================================
-- Triggers
-- ============================================================================
CREATE TRIGGER popups_updated_at BEFORE UPDATE ON popups
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- Function: Track popup impression
-- ============================================================================
CREATE OR REPLACE FUNCTION track_popup_impression(
  p_popup_id UUID,
  p_visitor_id TEXT,
  p_session_id TEXT DEFAULT NULL
) RETURNS BOOLEAN AS $$
DECLARE
  v_should_show BOOLEAN := true;
  v_popup RECORD;
  v_existing RECORD;
BEGIN
  -- Get popup
  SELECT * INTO v_popup FROM popups WHERE id = p_popup_id;
  IF NOT FOUND THEN RETURN false; END IF;
  
  -- Check frequency cap
  IF v_popup.frequency_cap->>'type' = 'once_ever' THEN
    SELECT * INTO v_existing FROM popup_impressions 
    WHERE popup_id = p_popup_id AND visitor_id = p_visitor_id LIMIT 1;
    IF FOUND THEN RETURN false; END IF;
    
  ELSIF v_popup.frequency_cap->>'type' = 'once_per_session' THEN
    SELECT * INTO v_existing FROM popup_impressions 
    WHERE popup_id = p_popup_id AND visitor_id = p_visitor_id AND session_id = p_session_id LIMIT 1;
    IF FOUND THEN RETURN false; END IF;
    
  ELSIF v_popup.frequency_cap->>'type' = 'once_per_day' THEN
    SELECT * INTO v_existing FROM popup_impressions 
    WHERE popup_id = p_popup_id AND visitor_id = p_visitor_id 
    AND created_at > NOW() - INTERVAL '24 hours' LIMIT 1;
    IF FOUND THEN RETURN false; END IF;
  END IF;
  
  -- Record impression
  INSERT INTO popup_impressions (popup_id, visitor_id, session_id)
  VALUES (p_popup_id, p_visitor_id, p_session_id);
  
  -- Update analytics
  INSERT INTO popup_analytics (popup_id, date, impressions, unique_impressions)
  VALUES (p_popup_id, CURRENT_DATE, 1, 1)
  ON CONFLICT (popup_id, date) DO UPDATE SET
    impressions = popup_analytics.impressions + 1;
  
  RETURN true;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- Function: Track popup conversion
-- ============================================================================
CREATE OR REPLACE FUNCTION track_popup_conversion(
  p_popup_id UUID,
  p_visitor_id TEXT
) RETURNS BOOLEAN AS $$
BEGIN
  -- Update impression record
  UPDATE popup_impressions
  SET converted = true, converted_at = NOW()
  WHERE popup_id = p_popup_id AND visitor_id = p_visitor_id AND converted = false;
  
  IF NOT FOUND THEN RETURN false; END IF;
  
  -- Update analytics
  UPDATE popup_analytics
  SET conversions = conversions + 1, unique_conversions = unique_conversions + 1
  WHERE popup_id = p_popup_id AND date = CURRENT_DATE;
  
  RETURN true;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### `types/popups.ts`
```typescript
export type PopupTriggerType =
  | 'exit_intent'
  | 'scroll_depth'
  | 'time_on_page'
  | 'page_views'
  | 'click'
  | 'manual';

export type PopupPosition =
  | 'center'
  | 'top'
  | 'bottom'
  | 'top_left'
  | 'top_right'
  | 'bottom_left'
  | 'bottom_right';

export type PopupAnimation = 'fade' | 'slide_up' | 'slide_down' | 'zoom' | 'none';

export type PopupContentType = 'email_capture' | 'announcement' | 'discount' | 'quiz_cta';

export type PopupStatus = 'draft' | 'active' | 'paused' | 'archived';

export interface PopupTriggerConfig {
  percentage?: number;  // for scroll_depth
  seconds?: number;     // for time_on_page
  count?: number;       // for page_views
  selector?: string;    // for click
}

export interface PopupContent {
  type: PopupContentType;
  headline?: string;
  body?: string;
  image_url?: string;
  cta_text?: string;
  cta_link?: string;
  discount_code?: string;
  email_placeholder?: string;
  success_message?: string;
}

export interface PopupTargeting {
  devices?: ('desktop' | 'mobile' | 'tablet')[];
  url_contains?: string[];
  url_excludes?: string[];
  referrer_contains?: string[];
  new_visitors_only?: boolean;
  returning_visitors_only?: boolean;
  exclude_if_converted?: boolean;
}

export interface PopupFrequencyCap {
  type: 'once_per_session' | 'once_per_day' | 'once_ever' | 'unlimited';
  max_impressions?: number;
}

export interface PopupStyle {
  background_color?: string;
  text_color?: string;
  accent_color?: string;
  border_radius?: number;
  max_width?: number;
}

export interface Popup {
  id: string;
  user_id: string;
  name: string;
  trigger_type: PopupTriggerType;
  trigger_config: PopupTriggerConfig;
  content: PopupContent;
  targeting: PopupTargeting;
  frequency_cap: PopupFrequencyCap;
  position: PopupPosition;
  animation: PopupAnimation;
  overlay_opacity: number;
  close_on_overlay_click: boolean;
  show_close_button: boolean;
  style: PopupStyle;
  status: PopupStatus;
  start_at?: string;
  end_at?: string;
  created_at: string;
  updated_at: string;
}

export interface PopupAnalytics {
  id: string;
  popup_id: string;
  date: string;
  impressions: number;
  closes: number;
  conversions: number;
  unique_impressions: number;
  unique_conversions: number;
}
```

### `app/api/popups/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { Popup } from '@/types/popups';

// GET /api/popups - List popups
export async function GET(request: NextRequest) {
  const supabase = createClient();
  
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const searchParams = request.nextUrl.searchParams;
  const status = searchParams.get('status');

  let query = supabase
    .from('popups')
    .select('*')
    .eq('user_id', user.id)
    .order('created_at', { ascending: false });

  if (status) {
    query = query.eq('status', status);
  }

  const { data: popups, error } = await query;

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  return NextResponse.json({ popups });
}

// POST /api/popups - Create popup
export async function POST(request: NextRequest) {
  const supabase = createClient();
  
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const body = await request.json();

  const { data: popup, error } = await supabase
    .from('popups')
    .insert({
      user_id: user.id,
      name: body.name,
      trigger_type: body.trigger_type || 'exit_intent',
      trigger_config: body.trigger_config || {},
      content: body.content || { type: 'announcement' },
      targeting: body.targeting || {},
      frequency_cap: body.frequency_cap || { type: 'once_per_session' },
      position: body.position || 'center',
      animation: body.animation || 'fade',
      overlay_opacity: body.overlay_opacity ?? 50,
      close_on_overlay_click: body.close_on_overlay_click ?? true,
      show_close_button: body.show_close_button ?? true,
      style: body.style || {},
      status: 'draft',
    })
    .select()
    .single();

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  return NextResponse.json({ popup }, { status: 201 });
}
```

### `app/api/popups/[id]/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

// GET /api/popups/[id] - Get popup details
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const supabase = createClient();
  
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { data: popup, error } = await supabase
    .from('popups')
    .select(`
      *,
      popup_analytics(
        date,
        impressions,
        conversions,
        unique_impressions,
        unique_conversions
      )
    `)
    .eq('id', params.id)
    .eq('user_id', user.id)
    .single();

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 404 });
  }

  return NextResponse.json({ popup });
}

// PATCH /api/popups/[id] - Update popup
export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const supabase = createClient();
  
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const body = await request.json();

  const { data: popup, error } = await supabase
    .from('popups')
    .update(body)
    .eq('id', params.id)
    .eq('user_id', user.id)
    .select()
    .single();

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  return NextResponse.json({ popup });
}

// DELETE /api/popups/[id] - Delete popup
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const supabase = createClient();
  
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { error } = await supabase
    .from('popups')
    .delete()
    .eq('id', params.id)
    .eq('user_id', user.id);

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  return NextResponse.json({ success: true });
}
```

### `app/api/popups/active/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

// GET /api/popups/active - Get active popups for public display
export async function GET(request: NextRequest) {
  const supabase = createClient();
  
  // This endpoint requires a user_id query param for public access
  const searchParams = request.nextUrl.searchParams;
  const userId = searchParams.get('user_id');
  
  if (!userId) {
    return NextResponse.json({ error: 'user_id required' }, { status: 400 });
  }

  const now = new Date().toISOString();

  const { data: popups, error } = await supabase
    .from('popups')
    .select('*')
    .eq('user_id', userId)
    .eq('status', 'active')
    .or(`start_at.is.null,start_at.lte.${now}`)
    .or(`end_at.is.null,end_at.gte.${now}`)
    .order('created_at', { ascending: false });

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  return NextResponse.json({ popups });
}
```

- **Step Dependencies**: Step 14.4
- **User Instructions**: Run migration `011a_popups.sql`

---

