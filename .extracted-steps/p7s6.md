## Step 10.2: Implement Product Creation Service

- **Task**: Build the service for creating products locally and syncing to Shopify.

- **Files**:

### `lib/products/product-service.ts`
```typescript
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { getAdminClient } from '@/lib/supabase/admin';
import { ShopifyClient } from '@/lib/integrations/shopify/client';
import { uploadFile, getFileBuffer, generateStorageKey, STORAGE_PATHS } from '@/lib/storage/storage-utils';
import type { CreateProductRequest, Product, ProductVariant } from '@/types/products';

interface ProductCreationResult {
  success: boolean;
  product?: Product;
  shopifyProductId?: string;
  error?: string;
}

export async function createProduct(
  userId: string,
  request: CreateProductRequest
): Promise<ProductCreationResult> {
  const supabase = createServerSupabaseClient();
  
  try {
    // Create local product record
    const { data: product, error: productError } = await supabase
      .from('products')
      .insert({
        user_id: userId,
        quote_id: request.quoteId,
        asset_id: request.assetId,
        title: request.title,
        description: request.description,
        collection: request.collection,
        tags: request.tags || [],
        status: 'draft',
      })
      .select()
      .single();

    if (productError || !product) {
      throw new Error(productError?.message || 'Failed to create product');
    }

    // Get pricing defaults
    const { data: pricingDefaults } = await supabase
      .from('product_pricing')
      .select('*')
      .or(`user_id.eq.${userId},is_system.eq.true`)
      .order('is_system', { ascending: true }); // User pricing takes precedence

    const pricingMap = new Map(pricingDefaults?.map((p) => [p.size, p]) || []);

    // Create variants
    const variantsToInsert = request.variants.map((v) => {
      const defaultPricing = pricingMap.get(v.size);
      const price = v.price || (v.is_digital 
        ? defaultPricing?.digital_price 
        : v.frame_style 
          ? defaultPricing?.framed_price 
          : defaultPricing?.base_price
      ) || 24.99;

      return {
        product_id: product.id,
        user_id: userId,
        title: v.frame_style 
          ? `${v.size} / ${v.frame_style} Frame`
          : v.size,
        size: v.size,
        frame_style: v.frame_style,
        price,
        is_digital: v.is_digital || false,
        sku: generateSku(product.id, v.size, v.frame_style),
      };
    });

    const { error: variantError } = await supabase
      .from('product_variants')
      .insert(variantsToInsert);

    if (variantError) {
      throw new Error(`Failed to create variants: ${variantError.message}`);
    }

    // Add images
    if (request.imageIds && request.imageIds.length > 0) {
      const imageInserts = await Promise.all(
        request.imageIds.map(async (id, index) => {
          // Try to find as asset first, then mockup
          let imageUrl: string | null = null;
          let sourceType: 'asset' | 'mockup' = 'asset';

          const { data: asset } = await supabase
            .from('assets')
            .select('file_url')
            .eq('id', id)
            .single();

          if (asset) {
            imageUrl = asset.file_url;
          } else {
            const { data: mockup } = await supabase
              .from('mockups')
              .select('file_url')
              .eq('id', id)
              .single();

            if (mockup) {
              imageUrl = mockup.file_url;
              sourceType = 'mockup';
            }
          }

          if (!imageUrl) return null;

          return {
            product_id: product.id,
            user_id: userId,
            position: index,
            src: imageUrl,
            source_type: sourceType,
            source_id: id,
          };
        })
      );

      const validImages = imageInserts.filter(Boolean);
      if (validImages.length > 0) {
        await supabase.from('product_images').insert(validImages);
      }
    }

    // Log activity
    await supabase.rpc('log_activity', {
      p_user_id: userId,
      p_action_type: 'product_created',
      p_details: {
        productId: product.id,
        title: request.title,
        variantCount: request.variants.length,
      },
      p_executed: true,
      p_module: 'products',
      p_reference_id: product.id,
      p_reference_table: 'products',
    });

    // Publish to Shopify if requested
    if (request.publishImmediately) {
      const publishResult = await publishProductToShopify(userId, product.id);
      if (!publishResult.success) {
        // Update product with pending status for approval
        await supabase
          .from('products')
          .update({ status: 'pending' })
          .eq('id', product.id);
      }
    }

    return {
      success: true,
      product: product as Product,
    };
  } catch (error) {
    console.error('Product creation error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

export async function publishProductToShopify(
  userId: string,
  productId: string
): Promise<ProductCreationResult> {
  const supabase = createServerSupabaseClient();
  const adminClient = getAdminClient();

  try {
    // Get product with variants and images
    const { data: product } = await supabase
      .from('products')
      .select(`
        *,
        variants:product_variants(*),
        images:product_images(*)
      `)
      .eq('id', productId)
      .eq('user_id', userId)
      .single();

    if (!product) {
      throw new Error('Product not found');
    }

    // Get Shopify credentials
    const { data: integration } = await supabase
      .from('integrations')
      .select('metadata')
      .eq('user_id', userId)
      .eq('provider', 'shopify')
      .eq('status', 'connected')
      .single();

    if (!integration) {
      throw new Error('Shopify not connected');
    }

    const shopDomain = integration.metadata.shop_domain;
    const accessToken = await adminClient.rpc('get_credential', {
      p_user_id: userId,
      p_provider: 'shopify',
      p_credential_type: 'access_token',
    });

    if (!accessToken.data) {
      throw new Error('Shopify access token not found');
    }

    const shopifyClient = new ShopifyClient({
      shop: shopDomain,
      accessToken: accessToken.data,
    });

    // Create Shopify product
    const shopifyProduct = await shopifyClient.createProduct({
      title: product.title,
      body_html: product.description || '',
      vendor: product.vendor,
      product_type: product.product_type,
      tags: product.tags.join(', '),
      status: 'active',
      variants: product.variants.map((v: ProductVariant) => ({
        title: v.title,
        price: String(v.price),
        sku: v.sku || undefined,
        inventory_quantity: v.is_digital ? 9999 : v.inventory_quantity,
        inventory_policy: v.is_digital ? 'continue' : 'deny',
        option1: v.size,
        option2: v.frame_style || undefined,
      })),
      images: product.images.map((img: { src: string; alt?: string }) => ({
        src: img.src,
        alt: img.alt || product.title,
      })),
      options: [
        { name: 'Size', values: [...new Set(product.variants.map((v: ProductVariant) => v.size))] },
        ...(product.variants.some((v: ProductVariant) => v.frame_style) 
          ? [{ name: 'Frame', values: [...new Set(product.variants.filter((v: ProductVariant) => v.frame_style).map((v: ProductVariant) => v.frame_style))] }]
          : []
        ),
      ],
    });

    // Update local product with Shopify IDs
    await supabase
      .from('products')
      .update({
        shopify_product_id: String(shopifyProduct.product.id),
        shopify_handle: shopifyProduct.product.handle,
        status: 'active',
        published_at: new Date().toISOString(),
        last_synced_at: new Date().toISOString(),
      })
      .eq('id', productId);

    // Update variant IDs
    for (const shopifyVariant of shopifyProduct.product.variants) {
      const localVariant = product.variants.find(
        (v: ProductVariant) => v.title === shopifyVariant.title || v.sku === shopifyVariant.sku
      );
      if (localVariant) {
        await supabase
          .from('product_variants')
          .update({ shopify_variant_id: String(shopifyVariant.id) })
          .eq('id', localVariant.id);
      }
    }

    // Log activity
    await supabase.rpc('log_activity', {
      p_user_id: userId,
      p_action_type: 'product_published',
      p_details: {
        productId,
        shopifyProductId: shopifyProduct.product.id,
      },
      p_executed: true,
      p_module: 'products',
      p_reference_id: productId,
      p_reference_table: 'products',
    });

    return {
      success: true,
      shopifyProductId: String(shopifyProduct.product.id),
    };
  } catch (error) {
    console.error('Shopify publish error:', error);
    
    // Update product with error
    await supabase
      .from('products')
      .update({
        sync_error: error instanceof Error ? error.message : 'Unknown error',
      })
      .eq('id', productId);

    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

function generateSku(productId: string, size: string, frameStyle?: string | null): string {
  const prefix = 'HH';
  const productPart = productId.slice(0, 8).toUpperCase();
  const sizePart = size.replace(/[^a-zA-Z0-9]/g, '');
  const framePart = frameStyle ? frameStyle.slice(0, 3).toUpperCase() : 'UNF';
  return `${prefix}-${productPart}-${sizePart}-${framePart}`;
}
```

- **Step Dependencies**: Step 10.1
- **User Instructions**: None

---

