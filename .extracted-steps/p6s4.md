## Step 8.1: Create Image Generation Service

- **Task**: Build the server-side image generation service using node-canvas.

- **Files**:

### `lib/design-engine/canvas-renderer.ts`
```typescript
import { createCanvas, registerFont, loadImage, type Canvas, type CanvasRenderingContext2D } from 'canvas';
import path from 'path';
import type { DesignConfig, ColorConfig, TypographyConfig, LayoutConfig } from '@/types/quotes';

// Register fonts (run once on server start)
const fontsRegistered = false;
export function registerFonts() {
  if (fontsRegistered) return;
  
  // Register Haven & Hold brand fonts
  // These should be placed in public/fonts/
  try {
    registerFont(path.join(process.cwd(), 'public/fonts/CormorantGaramond-Regular.ttf'), {
      family: 'Cormorant Garamond',
      weight: '400',
    });
    registerFont(path.join(process.cwd(), 'public/fonts/CormorantGaramond-Italic.ttf'), {
      family: 'Cormorant Garamond',
      weight: '400',
      style: 'italic',
    });
    registerFont(path.join(process.cwd(), 'public/fonts/CormorantGaramond-SemiBold.ttf'), {
      family: 'Cormorant Garamond',
      weight: '600',
    });
    registerFont(path.join(process.cwd(), 'public/fonts/Inter-Regular.ttf'), {
      family: 'Inter',
      weight: '400',
    });
    registerFont(path.join(process.cwd(), 'public/fonts/Inter-Medium.ttf'), {
      family: 'Inter',
      weight: '500',
    });
  } catch (error) {
    console.warn('Failed to register custom fonts, using system fonts:', error);
  }
}

export interface RenderOptions {
  width: number;
  height: number;
  text: string;
  attribution?: string;
  config: DesignConfig;
}

export interface RenderResult {
  buffer: Buffer;
  metadata: {
    width: number;
    height: number;
    textBounds: { x: number; y: number; width: number; height: number };
  };
}

export async function renderQuoteImage(options: RenderOptions): Promise<RenderResult> {
  registerFonts();
  
  const { width, height, text, attribution, config } = options;
  const { typography, colors, layout, decorations } = config;
  
  const canvas = createCanvas(width, height);
  const ctx = canvas.getContext('2d');
  
  // Fill background
  ctx.fillStyle = colors.background;
  ctx.fillRect(0, 0, width, height);
  
  // Apply decorations
  if (decorations.border) {
    ctx.strokeStyle = decorations.border_color === 'accent' ? colors.accent : decorations.border_color;
    ctx.lineWidth = decorations.border_width;
    const inset = decorations.border_width / 2;
    ctx.strokeRect(inset, inset, width - decorations.border_width, height - decorations.border_width);
  }
  
  // Calculate text area
  const padding = layout.padding;
  const maxWidth = (width - padding * 2) * (layout.max_width_percent / 100);
  const textAreaX = padding + (width - padding * 2 - maxWidth) / 2;
  
  // Set typography
  const fontSize = calculateFontSize(text, maxWidth, typography, ctx);
  ctx.font = `${typography.font_weight} ${fontSize}px "${typography.font_family}"`;
  ctx.fillStyle = colors.text;
  ctx.textAlign = layout.text_alignment;
  ctx.textBaseline = 'top';
  
  // Wrap text
  const lines = wrapText(ctx, text, maxWidth);
  const lineHeight = fontSize * typography.line_height;
  const totalTextHeight = lines.length * lineHeight;
  
  // Calculate attribution height if present
  let attributionHeight = 0;
  if (attribution && layout.include_attribution) {
    ctx.font = `${typography.attribution_font_size}px "${typography.attribution_font_family}"`;
    attributionHeight = typography.attribution_font_size * 1.5 + 20; // Line + spacing
  }
  
  // Calculate vertical position
  const totalContentHeight = totalTextHeight + attributionHeight;
  let startY: number;
  
  switch (layout.vertical_alignment) {
    case 'top':
      startY = padding;
      break;
    case 'bottom':
      startY = height - padding - totalContentHeight;
      break;
    case 'center':
    default:
      startY = (height - totalContentHeight) / 2;
  }
  
  // Render quote text
  ctx.font = `italic ${typography.font_weight} ${fontSize}px "${typography.font_family}"`;
  ctx.fillStyle = colors.text;
  
  let textX: number;
  switch (layout.text_alignment) {
    case 'left':
      textX = textAreaX;
      break;
    case 'right':
      textX = textAreaX + maxWidth;
      break;
    case 'center':
    default:
      textX = width / 2;
  }
  
  const textBounds = {
    x: textAreaX,
    y: startY,
    width: maxWidth,
    height: totalTextHeight,
  };
  
  lines.forEach((line, index) => {
    ctx.fillText(line, textX, startY + index * lineHeight);
  });
  
  // Render attribution
  if (attribution && layout.include_attribution) {
    ctx.font = `${typography.attribution_font_size}px "${typography.attribution_font_family}"`;
    ctx.fillStyle = colors.text;
    ctx.globalAlpha = 0.7;
    ctx.fillText(`— ${attribution}`, textX, startY + totalTextHeight + 20);
    ctx.globalAlpha = 1;
  }
  
  return {
    buffer: canvas.toBuffer('image/png'),
    metadata: {
      width,
      height,
      textBounds,
    },
  };
}

function calculateFontSize(
  text: string,
  maxWidth: number,
  typography: TypographyConfig,
  ctx: CanvasRenderingContext2D
): number {
  let fontSize = typography.font_size_base;
  
  // Adjust based on text length
  if (text.length > 200) {
    fontSize = fontSize * 0.7;
  } else if (text.length > 100) {
    fontSize = fontSize * 0.85;
  }
  
  // Ensure text fits width
  ctx.font = `${typography.font_weight} ${fontSize}px "${typography.font_family}"`;
  const testMetrics = ctx.measureText(text);
  
  if (testMetrics.width > maxWidth * 3) {
    fontSize = fontSize * 0.8;
  }
  
  return Math.round(fontSize);
}

function wrapText(ctx: CanvasRenderingContext2D, text: string, maxWidth: number): string[] {
  const words = text.split(' ');
  const lines: string[] = [];
  let currentLine = '';
  
  for (const word of words) {
    const testLine = currentLine ? `${currentLine} ${word}` : word;
    const metrics = ctx.measureText(testLine);
    
    if (metrics.width > maxWidth && currentLine) {
      lines.push(currentLine);
      currentLine = word;
    } else {
      currentLine = testLine;
    }
  }
  
  if (currentLine) {
    lines.push(currentLine);
  }
  
  return lines;
}
```

### `lib/design-engine/quality-checker.ts`
```typescript
import { createCanvas, loadImage } from 'canvas';

export interface QualityScores {
  readability: number;
  contrast: number;
  composition: number;
  overall: number;
}

export interface QualityCheckResult {
  scores: QualityScores;
  flags: string[];
  flagReasons: Record<string, string>;
  passed: boolean;
}

const MIN_THRESHOLDS = {
  readability: 0.6,
  contrast: 0.5,
  overall: 0.6,
};

export async function checkImageQuality(
  imageBuffer: Buffer,
  textBounds: { x: number; y: number; width: number; height: number }
): Promise<QualityCheckResult> {
  const img = await loadImage(imageBuffer);
  const canvas = createCanvas(img.width, img.height);
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0);
  
  const imageData = ctx.getImageData(0, 0, img.width, img.height);
  
  const scores: QualityScores = {
    readability: checkReadability(imageData, textBounds),
    contrast: checkContrast(imageData),
    composition: checkComposition(img.width, img.height, textBounds),
    overall: 0,
  };
  
  // Calculate overall score (weighted average)
  scores.overall = (
    scores.readability * 0.4 +
    scores.contrast * 0.3 +
    scores.composition * 0.3
  );
  
  // Determine flags
  const flags: string[] = [];
  const flagReasons: Record<string, string> = {};
  
  if (scores.readability < MIN_THRESHOLDS.readability) {
    flags.push('low_readability');
    flagReasons.low_readability = `Readability score ${(scores.readability * 100).toFixed(0)}% is below minimum ${(MIN_THRESHOLDS.readability * 100)}%`;
  }
  
  if (scores.contrast < MIN_THRESHOLDS.contrast) {
    flags.push('low_contrast');
    flagReasons.low_contrast = `Contrast score ${(scores.contrast * 100).toFixed(0)}% is below minimum ${(MIN_THRESHOLDS.contrast * 100)}%`;
  }
  
  if (scores.overall < MIN_THRESHOLDS.overall) {
    flags.push('low_overall_quality');
    flagReasons.low_overall_quality = `Overall quality ${(scores.overall * 100).toFixed(0)}% is below minimum ${(MIN_THRESHOLDS.overall * 100)}%`;
  }
  
  return {
    scores,
    flags,
    flagReasons,
    passed: flags.length === 0,
  };
}

function checkReadability(
  imageData: ImageData,
  textBounds: { x: number; y: number; width: number; height: number }
): number {
  // Sample pixels in text area to check for uniform background
  const { x, y, width, height } = textBounds;
  const data = imageData.data;
  const imgWidth = imageData.width;
  
  let variance = 0;
  let samples = 0;
  const colors: Array<{ r: number; g: number; b: number }> = [];
  
  // Sample every 10th pixel in text area
  for (let py = Math.max(0, y); py < Math.min(y + height, imageData.height); py += 10) {
    for (let px = Math.max(0, x); px < Math.min(x + width, imgWidth); px += 10) {
      const idx = (py * imgWidth + px) * 4;
      colors.push({
        r: data[idx],
        g: data[idx + 1],
        b: data[idx + 2],
      });
      samples++;
    }
  }
  
  if (samples === 0) return 0.8; // Default if no samples
  
  // Calculate variance in brightness
  const brightnessValues = colors.map(c => (c.r + c.g + c.b) / 3);
  const avgBrightness = brightnessValues.reduce((a, b) => a + b, 0) / brightnessValues.length;
  variance = brightnessValues.reduce((sum, b) => sum + Math.pow(b - avgBrightness, 2), 0) / brightnessValues.length;
  
  // Lower variance = better readability (more uniform background)
  // Score: 1.0 for variance < 100, decreasing to 0.5 for variance > 2000
  const readabilityScore = Math.max(0.5, 1 - (variance / 2000));
  
  return Math.min(1, readabilityScore);
}

function checkContrast(imageData: ImageData): number {
  const data = imageData.data;
  
  // Get average foreground and background colors
  // Assuming text is darker than background in our design
  let minBrightness = 255;
  let maxBrightness = 0;
  
  for (let i = 0; i < data.length; i += 4 * 100) { // Sample every 100th pixel
    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
    minBrightness = Math.min(minBrightness, brightness);
    maxBrightness = Math.max(maxBrightness, brightness);
  }
  
  // Calculate contrast ratio
  const contrastRatio = (maxBrightness - minBrightness) / 255;
  
  // Score: We want decent contrast but not extreme
  // Ideal is around 0.3-0.7
  if (contrastRatio < 0.2) return 0.5;
  if (contrastRatio > 0.8) return 0.8;
  return 0.9 + (0.1 * (1 - Math.abs(contrastRatio - 0.5) / 0.3));
}

function checkComposition(
  width: number,
  height: number,
  textBounds: { x: number; y: number; width: number; height: number }
): number {
  // Check if text is well-positioned
  const centerX = width / 2;
  const centerY = height / 2;
  const textCenterX = textBounds.x + textBounds.width / 2;
  const textCenterY = textBounds.y + textBounds.height / 2;
  
  // Distance from center as percentage of dimensions
  const xOffset = Math.abs(textCenterX - centerX) / width;
  const yOffset = Math.abs(textCenterY - centerY) / height;
  
  // Check margin compliance
  const minMargin = Math.min(width, height) * 0.05;
  const hasAdequateMargins = 
    textBounds.x >= minMargin &&
    textBounds.y >= minMargin &&
    (textBounds.x + textBounds.width) <= (width - minMargin) &&
    (textBounds.y + textBounds.height) <= (height - minMargin);
  
  // Score based on centering and margins
  let score = 1.0;
  score -= xOffset * 0.3; // Penalize horizontal offset
  score -= yOffset * 0.3; // Penalize vertical offset
  if (!hasAdequateMargins) score -= 0.2;
  
  return Math.max(0.5, Math.min(1, score));
}
```

### `lib/design-engine/format-specs.ts`
```typescript
// Output format specifications per Feature 7 spec

export interface FormatSpec {
  id: string;
  name: string;
  category: 'social' | 'print';
  width: number;
  height: number;
  aspectRatio: string;
  dpi: number;
}

export const SOCIAL_FORMATS: FormatSpec[] = [
  {
    id: 'pinterest',
    name: 'Pinterest Pin',
    category: 'social',
    width: 1000,
    height: 1500,
    aspectRatio: '2:3',
    dpi: 72,
  },
  {
    id: 'instagram_post',
    name: 'Instagram Post',
    category: 'social',
    width: 1080,
    height: 1080,
    aspectRatio: '1:1',
    dpi: 72,
  },
  {
    id: 'instagram_story',
    name: 'Instagram Story',
    category: 'social',
    width: 1080,
    height: 1920,
    aspectRatio: '9:16',
    dpi: 72,
  },
];

export const PRINT_FORMATS: FormatSpec[] = [
  {
    id: 'print_8x10',
    name: '8×10"',
    category: 'print',
    width: 2400,
    height: 3000,
    aspectRatio: '4:5',
    dpi: 300,
  },
  {
    id: 'print_11x14',
    name: '11×14"',
    category: 'print',
    width: 3300,
    height: 4200,
    aspectRatio: '11:14',
    dpi: 300,
  },
  {
    id: 'print_16x20',
    name: '16×20"',
    category: 'print',
    width: 4800,
    height: 6000,
    aspectRatio: '4:5',
    dpi: 300,
  },
  {
    id: 'print_12x16',
    name: '12×16"',
    category: 'print',
    width: 3600,
    height: 4800,
    aspectRatio: '3:4',
    dpi: 300,
  },
  {
    id: 'print_18x24',
    name: '18×24"',
    category: 'print',
    width: 5400,
    height: 7200,
    aspectRatio: '3:4',
    dpi: 300,
  },
  {
    id: 'print_12x18',
    name: '12×18"',
    category: 'print',
    width: 3600,
    height: 5400,
    aspectRatio: '2:3',
    dpi: 300,
  },
  {
    id: 'print_16x24',
    name: '16×24"',
    category: 'print',
    width: 4800,
    height: 7200,
    aspectRatio: '2:3',
    dpi: 300,
  },
  {
    id: 'print_24x36',
    name: '24×36"',
    category: 'print',
    width: 7200,
    height: 10800,
    aspectRatio: '2:3',
    dpi: 300,
  },
  {
    id: 'print_a4',
    name: 'A4',
    category: 'print',
    width: 2480,
    height: 3508,
    aspectRatio: '1:1.414',
    dpi: 300,
  },
  {
    id: 'print_a3',
    name: 'A3',
    category: 'print',
    width: 3508,
    height: 4961,
    aspectRatio: '1:1.414',
    dpi: 300,
  },
];

export const ALL_FORMATS = [...SOCIAL_FORMATS, ...PRINT_FORMATS];

export function getFormatSpec(formatId: string): FormatSpec | undefined {
  return ALL_FORMATS.find((f) => f.id === formatId);
}

export function getFormatsByCategory(category: 'social' | 'print'): FormatSpec[] {
  return ALL_FORMATS.filter((f) => f.category === category);
}
```

- **Step Dependencies**: Step 7.1
- **User Instructions**: 
  1. Download and place font files in `public/fonts/`
  2. Run `npm install canvas` (may require system dependencies)

---

