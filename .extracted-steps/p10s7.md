## Step 19.2: Implement Loyalty Service

- **Task**: Create the service for managing points, tiers, and rewards.

- **Files**:

### `lib/loyalty/loyalty-service.ts`
```typescript
import { createServerSupabaseClient } from '@/lib/supabase/server';
import type { CustomerLoyalty, LoyaltyReward, PointsTransaction, LoyaltyTier } from '@/types/loyalty';
import { nanoid } from 'nanoid';

export async function getOrCreateCustomerLoyalty(
  userId: string,
  customerId: string
): Promise<CustomerLoyalty | null> {
  const supabase = createServerSupabaseClient();

  // Check for existing
  const { data: existing } = await supabase
    .from('customer_loyalty')
    .select('*, tier:loyalty_tiers(*)')
    .eq('customer_id', customerId)
    .single();

  if (existing) {
    return existing as CustomerLoyalty;
  }

  // Get starter tier
  const { data: starterTier } = await supabase
    .from('loyalty_tiers')
    .select('id')
    .eq('user_id', userId)
    .order('tier_order', { ascending: true })
    .limit(1)
    .single();

  // Create new loyalty record
  const { data: newLoyalty, error } = await supabase
    .from('customer_loyalty')
    .insert({
      user_id: userId,
      customer_id: customerId,
      tier_id: starterTier?.id,
      referral_code: nanoid(8).toUpperCase(),
    })
    .select('*, tier:loyalty_tiers(*)')
    .single();

  if (error) {
    console.error('Create customer loyalty error:', error);
    return null;
  }

  return newLoyalty as CustomerLoyalty;
}

export async function awardPointsForPurchase(
  userId: string,
  customerId: string,
  orderValue: number,
  orderId: string
): Promise<{ success: boolean; pointsAwarded: number; error?: string }> {
  const supabase = createServerSupabaseClient();

  try {
    // Ensure loyalty record exists
    await getOrCreateCustomerLoyalty(userId, customerId);

    // Calculate points (1 point per dollar by default)
    const basePoints = Math.floor(orderValue);

    const { data: transactionId, error } = await supabase.rpc('award_points', {
      p_customer_id: customerId,
      p_type: 'earn_purchase',
      p_points: basePoints,
      p_reference_id: orderId,
      p_reference_type: 'order',
      p_description: `Points earned from order ${orderId}`,
    });

    if (error) {
      throw new Error(error.message);
    }

    // Get updated loyalty to see final points (after multiplier)
    const { data: loyalty } = await supabase
      .from('customer_loyalty')
      .select('points_balance')
      .eq('customer_id', customerId)
      .single();

    // Log activity
    await supabase.rpc('log_activity', {
      p_user_id: userId,
      p_action_type: 'points_awarded',
      p_details: {
        customerId,
        orderId,
        basePoints,
        transactionId,
      },
      p_executed: true,
      p_module: 'loyalty',
    });

    return { success: true, pointsAwarded: basePoints };
  } catch (error) {
    console.error('Award points error:', error);
    return {
      success: false,
      pointsAwarded: 0,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

export async function redeemReward(
  userId: string,
  customerId: string,
  rewardId: string
): Promise<{
  success: boolean;
  discountCode?: string;
  error?: string;
}> {
  const supabase = createServerSupabaseClient();

  try {
    // Get loyalty and reward
    const { data: loyalty } = await supabase
      .from('customer_loyalty')
      .select('*')
      .eq('customer_id', customerId)
      .single();

    const { data: reward } = await supabase
      .from('loyalty_rewards')
      .select('*')
      .eq('id', rewardId)
      .eq('is_active', true)
      .single();

    if (!loyalty || !reward) {
      return { success: false, error: 'Loyalty or reward not found' };
    }

    // Check points
    if (loyalty.points_balance < reward.points_cost) {
      return { success: false, error: 'Insufficient points' };
    }

    // Check tier requirement
    if (reward.min_tier_id && reward.min_tier_id !== loyalty.tier_id) {
      // TODO: Proper tier comparison
      return { success: false, error: 'Tier requirement not met' };
    }

    // Check availability
    if (reward.total_available !== null && reward.total_redeemed >= reward.total_available) {
      return { success: false, error: 'Reward no longer available' };
    }

    // Deduct points
    const { data: transactionId, error: pointsError } = await supabase.rpc('award_points', {
      p_customer_id: customerId,
      p_type: 'redeem_discount',
      p_points: -reward.points_cost,
      p_reference_id: rewardId,
      p_reference_type: 'reward',
      p_description: `Redeemed: ${reward.name}`,
    });

    if (pointsError) {
      throw new Error(pointsError.message);
    }

    // Generate discount code
    const discountCode = `HH${nanoid(6).toUpperCase()}`;

    // Create redemption record
    const { error: redemptionError } = await supabase
      .from('reward_redemptions')
      .insert({
        user_id: userId,
        customer_loyalty_id: loyalty.id,
        reward_id: rewardId,
        points_transaction_id: transactionId,
        points_spent: reward.points_cost,
        discount_code: discountCode,
        expires_at: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(), // 30 days
      });

    if (redemptionError) {
      throw new Error(redemptionError.message);
    }

    // Update reward redeemed count
    await supabase
      .from('loyalty_rewards')
      .update({ total_redeemed: reward.total_redeemed + 1 })
      .eq('id', rewardId);

    // Update loyalty redeemed lifetime
    await supabase
      .from('customer_loyalty')
      .update({
        points_redeemed_lifetime: loyalty.points_redeemed_lifetime + reward.points_cost,
      })
      .eq('id', loyalty.id);

    return { success: true, discountCode };
  } catch (error) {
    console.error('Redeem reward error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

export async function processReferral(
  userId: string,
  referralCode: string,
  newCustomerId: string,
  orderValue: number
): Promise<{ success: boolean; pointsAwarded: number; error?: string }> {
  const supabase = createServerSupabaseClient();

  try {
    // Find referrer by code
    const { data: referrer } = await supabase
      .from('customer_loyalty')
      .select('customer_id')
      .eq('referral_code', referralCode)
      .single();

    if (!referrer) {
      return { success: false, pointsAwarded: 0, error: 'Invalid referral code' };
    }

    // Prevent self-referral
    if (referrer.customer_id === newCustomerId) {
      return { success: false, pointsAwarded: 0, error: 'Cannot refer yourself' };
    }

    // Award points to referrer (10% of order value as points)
    const referralPoints = Math.floor(orderValue * 0.1);

    await supabase.rpc('award_points', {
      p_customer_id: referrer.customer_id,
      p_type: 'earn_referral',
      p_points: referralPoints,
      p_reference_id: newCustomerId,
      p_reference_type: 'referral',
      p_description: 'Referral bonus',
    });

    // Update referral stats
    await supabase
      .from('customer_loyalty')
      .update({
        referrals_count: supabase.sql`referrals_count + 1`,
        referral_points_earned: supabase.sql`referral_points_earned + ${referralPoints}`,
      })
      .eq('customer_id', referrer.customer_id);

    return { success: true, pointsAwarded: referralPoints };
  } catch (error) {
    console.error('Process referral error:', error);
    return {
      success: false,
      pointsAwarded: 0,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

export async function getLoyaltyDashboard(userId: string): Promise<{
  totalMembers: number;
  totalPointsOutstanding: number;
  tierDistribution: Record<string, number>;
  recentRedemptions: number;
  topReferrers: Array<{ email: string; referrals: number; points: number }>;
}> {
  const supabase = createServerSupabaseClient();

  const { data: loyaltyRecords } = await supabase
    .from('customer_loyalty')
    .select('points_balance, tier_id, referrals_count, referral_points_earned, customers(email)')
    .eq('user_id', userId);

  const { data: tiers } = await supabase
    .from('loyalty_tiers')
    .select('id, name')
    .eq('user_id', userId);

  const tierMap = new Map(tiers?.map((t) => [t.id, t.name]) || []);

  const tierDistribution: Record<string, number> = {};
  let totalPoints = 0;

  for (const record of loyaltyRecords || []) {
    totalPoints += record.points_balance;
    const tierName = record.tier_id ? tierMap.get(record.tier_id) || 'Unknown' : 'None';
    tierDistribution[tierName] = (tierDistribution[tierName] || 0) + 1;
  }

  // Get recent redemptions count
  const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();
  const { count: recentRedemptions } = await supabase
    .from('reward_redemptions')
    .select('*', { count: 'exact', head: true })
    .eq('user_id', userId)
    .gte('created_at', thirtyDaysAgo);

  // Get top referrers
  const topReferrers = (loyaltyRecords || [])
    .filter((r) => r.referrals_count > 0)
    .sort((a, b) => b.referrals_count - a.referrals_count)
    .slice(0, 5)
    .map((r) => ({
      email: r.customers?.email || 'Unknown',
      referrals: r.referrals_count,
      points: r.referral_points_earned,
    }));

  return {
    totalMembers: loyaltyRecords?.length || 0,
    totalPointsOutstanding: totalPoints,
    tierDistribution,
    recentRedemptions: recentRedemptions || 0,
    topReferrers,
  };
}
```

- **Step Dependencies**: Step 19.1
- **User Instructions**: None

---

