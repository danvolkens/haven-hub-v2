## Step 14.6: Implement Popup Display System

- **Task**: Build the client-side popup display and tracking system.

- **Files**:

### `lib/popups/trigger-handlers.ts`
```typescript
type TriggerCallback = () => void;

// Exit Intent Detection
export function setupExitIntent(callback: TriggerCallback): () => void {
  const handleMouseLeave = (e: MouseEvent) => {
    // Only trigger when mouse leaves through top of viewport
    if (e.clientY <= 0) {
      callback();
    }
  };

  document.addEventListener('mouseleave', handleMouseLeave);
  
  return () => {
    document.removeEventListener('mouseleave', handleMouseLeave);
  };
}

// Scroll Depth Detection
export function setupScrollDepth(percentage: number, callback: TriggerCallback): () => void {
  let triggered = false;

  const handleScroll = () => {
    if (triggered) return;

    const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
    const currentScroll = window.scrollY;
    const scrollPercentage = (currentScroll / scrollHeight) * 100;

    if (scrollPercentage >= percentage) {
      triggered = true;
      callback();
    }
  };

  window.addEventListener('scroll', handleScroll, { passive: true });
  
  return () => {
    window.removeEventListener('scroll', handleScroll);
  };
}

// Time on Page Detection
export function setupTimeOnPage(seconds: number, callback: TriggerCallback): () => void {
  const timer = setTimeout(callback, seconds * 1000);
  
  return () => {
    clearTimeout(timer);
  };
}

// Page Views Detection (uses sessionStorage)
export function setupPageViews(count: number, callback: TriggerCallback): () => void {
  const key = 'haven_page_views';
  const currentViews = parseInt(sessionStorage.getItem(key) || '0', 10) + 1;
  sessionStorage.setItem(key, String(currentViews));

  if (currentViews >= count) {
    // Small delay to allow page to render
    const timer = setTimeout(callback, 500);
    return () => clearTimeout(timer);
  }

  return () => {};
}

// Click Trigger
export function setupClickTrigger(selector: string, callback: TriggerCallback): () => void {
  const handleClick = (e: Event) => {
    const target = e.target as Element;
    if (target.matches(selector) || target.closest(selector)) {
      callback();
    }
  };

  document.addEventListener('click', handleClick);
  
  return () => {
    document.removeEventListener('click', handleClick);
  };
}
```

### `lib/popups/frequency-tracker.ts`
```typescript
import { PopupFrequencyCap } from '@/types/popups';

const STORAGE_KEY = 'haven_popup_impressions';

interface ImpressionRecord {
  popup_id: string;
  session_id: string;
  timestamp: number;
  converted: boolean;
}

function getImpressions(): ImpressionRecord[] {
  try {
    const data = localStorage.getItem(STORAGE_KEY);
    return data ? JSON.parse(data) : [];
  } catch {
    return [];
  }
}

function saveImpressions(impressions: ImpressionRecord[]): void {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(impressions));
  } catch {
    // Storage might be full or disabled
  }
}

function getSessionId(): string {
  const key = 'haven_session_id';
  let sessionId = sessionStorage.getItem(key);
  if (!sessionId) {
    sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    sessionStorage.setItem(key, sessionId);
  }
  return sessionId;
}

export function shouldShowPopup(popupId: string, frequencyCap: PopupFrequencyCap): boolean {
  const impressions = getImpressions();
  const sessionId = getSessionId();
  const now = Date.now();
  const oneDayAgo = now - (24 * 60 * 60 * 1000);

  const popupImpressions = impressions.filter(i => i.popup_id === popupId);

  switch (frequencyCap.type) {
    case 'once_ever':
      return popupImpressions.length === 0;

    case 'once_per_session':
      return !popupImpressions.some(i => i.session_id === sessionId);

    case 'once_per_day':
      return !popupImpressions.some(i => i.timestamp > oneDayAgo);

    case 'unlimited':
      if (frequencyCap.max_impressions) {
        return popupImpressions.length < frequencyCap.max_impressions;
      }
      return true;

    default:
      return true;
  }
}

export function recordImpression(popupId: string): void {
  const impressions = getImpressions();
  const sessionId = getSessionId();

  impressions.push({
    popup_id: popupId,
    session_id: sessionId,
    timestamp: Date.now(),
    converted: false,
  });

  // Clean up old impressions (older than 30 days)
  const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
  const cleanedImpressions = impressions.filter(i => i.timestamp > thirtyDaysAgo);

  saveImpressions(cleanedImpressions);
}

export function recordConversion(popupId: string): void {
  const impressions = getImpressions();
  const sessionId = getSessionId();

  const index = impressions.findIndex(
    i => i.popup_id === popupId && i.session_id === sessionId && !i.converted
  );

  if (index !== -1) {
    impressions[index].converted = true;
    saveImpressions(impressions);
  }
}

export function hasConverted(popupId: string): boolean {
  const impressions = getImpressions();
  return impressions.some(i => i.popup_id === popupId && i.converted);
}
```

### `components/popups/popup-manager.tsx`
```tsx
'use client';

import { useEffect, useState, useCallback } from 'react';
import { Popup } from '@/types/popups';
import { PopupModal } from './popup-modal';
import {
  setupExitIntent,
  setupScrollDepth,
  setupTimeOnPage,
  setupPageViews,
  setupClickTrigger,
} from '@/lib/popups/trigger-handlers';
import {
  shouldShowPopup,
  recordImpression,
  hasConverted,
} from '@/lib/popups/frequency-tracker';

interface PopupManagerProps {
  userId: string;
}

export function PopupManager({ userId }: PopupManagerProps) {
  const [popups, setPopups] = useState<Popup[]>([]);
  const [activePopup, setActivePopup] = useState<Popup | null>(null);
  const [triggeredPopups, setTriggeredPopups] = useState<Set<string>>(new Set());

  // Fetch active popups
  useEffect(() => {
    async function fetchPopups() {
      try {
        const response = await fetch(`/api/popups/active?user_id=${userId}`);
        if (response.ok) {
          const { popups } = await response.json();
          setPopups(popups);
        }
      } catch (error) {
        console.error('Failed to fetch popups:', error);
      }
    }

    fetchPopups();
  }, [userId]);

  // Check targeting rules
  const matchesTargeting = useCallback((popup: Popup): boolean => {
    const { targeting } = popup;

    // Device targeting
    if (targeting.devices && targeting.devices.length > 0) {
      const isMobile = window.innerWidth < 768;
      const isTablet = window.innerWidth >= 768 && window.innerWidth < 1024;
      const device = isMobile ? 'mobile' : isTablet ? 'tablet' : 'desktop';
      if (!targeting.devices.includes(device)) return false;
    }

    // URL rules
    if (targeting.url_contains && targeting.url_contains.length > 0) {
      if (!targeting.url_contains.some(str => window.location.href.includes(str))) {
        return false;
      }
    }
    if (targeting.url_excludes && targeting.url_excludes.length > 0) {
      if (targeting.url_excludes.some(str => window.location.href.includes(str))) {
        return false;
      }
    }

    // Conversion exclusion
    if (targeting.exclude_if_converted && hasConverted(popup.id)) {
      return false;
    }

    return true;
  }, []);

  // Trigger popup
  const triggerPopup = useCallback((popup: Popup) => {
    if (triggeredPopups.has(popup.id)) return;
    if (!shouldShowPopup(popup.id, popup.frequency_cap)) return;
    if (!matchesTargeting(popup)) return;

    setTriggeredPopups(prev => new Set([...prev, popup.id]));
    setActivePopup(popup);
    recordImpression(popup.id);

    // Track impression server-side
    fetch('/api/popups/track', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        popup_id: popup.id,
        event: 'impression',
      }),
    }).catch(console.error);
  }, [triggeredPopups, matchesTargeting]);

  // Set up trigger handlers
  useEffect(() => {
    const cleanups: (() => void)[] = [];

    popups.forEach(popup => {
      if (triggeredPopups.has(popup.id)) return;
      if (!shouldShowPopup(popup.id, popup.frequency_cap)) return;
      if (!matchesTargeting(popup)) return;

      switch (popup.trigger_type) {
        case 'exit_intent':
          cleanups.push(setupExitIntent(() => triggerPopup(popup)));
          break;
        case 'scroll_depth':
          const percentage = popup.trigger_config.percentage || 50;
          cleanups.push(setupScrollDepth(percentage, () => triggerPopup(popup)));
          break;
        case 'time_on_page':
          const seconds = popup.trigger_config.seconds || 30;
          cleanups.push(setupTimeOnPage(seconds, () => triggerPopup(popup)));
          break;
        case 'page_views':
          const count = popup.trigger_config.count || 3;
          cleanups.push(setupPageViews(count, () => triggerPopup(popup)));
          break;
        case 'click':
          const selector = popup.trigger_config.selector || '.trigger-popup';
          cleanups.push(setupClickTrigger(selector, () => triggerPopup(popup)));
          break;
      }
    });

    return () => {
      cleanups.forEach(cleanup => cleanup());
    };
  }, [popups, triggeredPopups, triggerPopup, matchesTargeting]);

  const handleClose = () => {
    setActivePopup(null);
  };

  const handleConversion = async () => {
    if (!activePopup) return;

    // Track conversion server-side
    await fetch('/api/popups/track', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        popup_id: activePopup.id,
        event: 'conversion',
      }),
    }).catch(console.error);
  };

  if (!activePopup) return null;

  return (
    <PopupModal
      popup={activePopup}
      onClose={handleClose}
      onConversion={handleConversion}
    />
  );
}
```

### `components/popups/popup-modal.tsx`
```tsx
'use client';

import { useState, useEffect } from 'react';
import { Popup } from '@/types/popups';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { X } from 'lucide-react';
import { recordConversion } from '@/lib/popups/frequency-tracker';

interface PopupModalProps {
  popup: Popup;
  onClose: () => void;
  onConversion: () => void;
}

export function PopupModal({ popup, onClose, onConversion }: PopupModalProps) {
  const [isVisible, setIsVisible] = useState(false);
  const [email, setEmail] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showSuccess, setShowSuccess] = useState(false);

  useEffect(() => {
    // Animate in
    requestAnimationFrame(() => setIsVisible(true));
  }, []);

  const handleClose = () => {
    setIsVisible(false);
    setTimeout(onClose, 200);
  };

  const handleOverlayClick = () => {
    if (popup.close_on_overlay_click) {
      handleClose();
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!email || isSubmitting) return;

    setIsSubmitting(true);

    try {
      // Submit to lead capture API
      await fetch('/api/leads', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email,
          source: 'popup',
          popup_id: popup.id,
        }),
      });

      recordConversion(popup.id);
      onConversion();
      setShowSuccess(true);

      setTimeout(() => {
        handleClose();
      }, 2000);
    } catch (error) {
      console.error('Popup submission failed:', error);
    } finally {
      setIsSubmitting(false);
    }
  };

  const getPositionStyles = (): string => {
    switch (popup.position) {
      case 'top': return 'items-start pt-20';
      case 'bottom': return 'items-end pb-20';
      case 'top_left': return 'items-start justify-start pt-20 pl-20';
      case 'top_right': return 'items-start justify-end pt-20 pr-20';
      case 'bottom_left': return 'items-end justify-start pb-20 pl-20';
      case 'bottom_right': return 'items-end justify-end pb-20 pr-20';
      default: return 'items-center justify-center';
    }
  };

  const getAnimationStyles = (): string => {
    if (!isVisible) {
      switch (popup.animation) {
        case 'slide_up': return 'translate-y-8 opacity-0';
        case 'slide_down': return '-translate-y-8 opacity-0';
        case 'zoom': return 'scale-95 opacity-0';
        case 'none': return '';
        default: return 'opacity-0';
      }
    }
    return 'translate-y-0 scale-100 opacity-100';
  };

  return (
    <div
      className={`fixed inset-0 z-50 flex ${getPositionStyles()} transition-opacity duration-200 ${
        isVisible ? 'opacity-100' : 'opacity-0'
      }`}
      onClick={handleOverlayClick}
    >
      {/* Overlay */}
      <div
        className="absolute inset-0 bg-black"
        style={{ opacity: popup.overlay_opacity / 100 }}
      />

      {/* Modal */}
      <div
        className={`relative bg-white rounded-xl shadow-2xl transition-all duration-200 ${getAnimationStyles()}`}
        style={{
          maxWidth: popup.style.max_width || 480,
          backgroundColor: popup.style.background_color,
          color: popup.style.text_color,
          borderRadius: popup.style.border_radius,
        }}
        onClick={(e) => e.stopPropagation()}
      >
        {/* Close Button */}
        {popup.show_close_button && (
          <button
            onClick={handleClose}
            className="absolute top-4 right-4 p-1 rounded-full hover:bg-black/10 transition-colors"
          >
            <X className="h-5 w-5" />
          </button>
        )}

        {/* Content */}
        <div className="p-8">
          {showSuccess ? (
            <div className="text-center py-8">
              <div className="text-4xl mb-4">âœ“</div>
              <p className="text-lg font-semibold">
                {popup.content.success_message || 'Thank you!'}
              </p>
            </div>
          ) : (
            <>
              {popup.content.image_url && (
                <img
                  src={popup.content.image_url}
                  alt=""
                  className="w-full h-48 object-cover rounded-lg mb-6"
                />
              )}

              {popup.content.headline && (
                <h2 className="text-2xl font-bold mb-2">{popup.content.headline}</h2>
              )}

              {popup.content.body && (
                <p className="text-muted-foreground mb-6">{popup.content.body}</p>
              )}

              {popup.content.discount_code && (
                <div className="bg-gray-100 rounded-lg p-4 mb-6 text-center">
                  <div className="text-sm text-muted-foreground mb-1">Your code:</div>
                  <div className="text-xl font-mono font-bold">
                    {popup.content.discount_code}
                  </div>
                </div>
              )}

              {popup.content.type === 'email_capture' && (
                <form onSubmit={handleSubmit} className="space-y-4">
                  <Input
                    type="email"
                    placeholder={popup.content.email_placeholder || 'Enter your email'}
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    required
                  />
                  <Button
                    type="submit"
                    className="w-full"
                    disabled={isSubmitting}
                    style={{ backgroundColor: popup.style.accent_color }}
                  >
                    {isSubmitting ? 'Submitting...' : popup.content.cta_text || 'Subscribe'}
                  </Button>
                </form>
              )}

              {popup.content.type !== 'email_capture' && popup.content.cta_text && (
                <Button
                  className="w-full"
                  onClick={() => {
                    if (popup.content.cta_link) {
                      window.location.href = popup.content.cta_link;
                    }
                    recordConversion(popup.id);
                    onConversion();
                    handleClose();
                  }}
                  style={{ backgroundColor: popup.style.accent_color }}
                >
                  {popup.content.cta_text}
                </Button>
              )}
            </>
          )}
        </div>
      </div>
    </div>
  );
}
```

### `app/(public)/layout.tsx` (update to include PopupManager)
```tsx
import { PopupManager } from '@/components/popups/popup-manager';

// Add to the public layout body:
// <PopupManager userId={HAVEN_USER_ID} />
// Note: HAVEN_USER_ID would be configured per deployment
```

- **Step Dependencies**: Step 14.5
- **User Instructions**: None

---

