## Step 24.4: Implement Performance & Caching

- **Task**: Add Redis caching for frequently accessed data.

- **Files**:

### `lib/cache/redis-cache.ts`
```typescript
import { Redis } from '@upstash/redis';

const redis = Redis.fromEnv();

const DEFAULT_TTL = 60 * 5; // 5 minutes

export interface CacheOptions {
  ttl?: number;
  tags?: string[];
}

export async function cacheGet<T>(key: string): Promise<T | null> {
  try {
    const data = await redis.get(key);
    return data as T | null;
  } catch (error) {
    console.error('Cache get error:', error);
    return null;
  }
}

export async function cacheSet(
  key: string,
  value: any,
  options: CacheOptions = {}
): Promise<void> {
  const { ttl = DEFAULT_TTL, tags = [] } = options;

  try {
    await redis.set(key, value, { ex: ttl });

    // Store tags for invalidation
    if (tags.length > 0) {
      for (const tag of tags) {
        await redis.sadd(`cache:tag:${tag}`, key);
      }
    }
  } catch (error) {
    console.error('Cache set error:', error);
  }
}

export async function cacheDelete(key: string): Promise<void> {
  try {
    await redis.del(key);
  } catch (error) {
    console.error('Cache delete error:', error);
  }
}

export async function cacheInvalidateByTag(tag: string): Promise<void> {
  try {
    const keys = await redis.smembers(`cache:tag:${tag}`);
    
    if (keys.length > 0) {
      await redis.del(...keys);
      await redis.del(`cache:tag:${tag}`);
    }
  } catch (error) {
    console.error('Cache invalidate error:', error);
  }
}

// Cache wrapper for async functions
export function withCache<T>(
  key: string,
  fn: () => Promise<T>,
  options: CacheOptions = {}
): Promise<T> {
  return new Promise(async (resolve, reject) => {
    try {
      // Try cache first
      const cached = await cacheGet<T>(key);
      if (cached !== null) {
        return resolve(cached);
      }

      // Execute function
      const result = await fn();

      // Cache result
      await cacheSet(key, result, options);

      resolve(result);
    } catch (error) {
      reject(error);
    }
  });
}

// User-specific cache key generator
export function userCacheKey(userId: string, ...parts: string[]): string {
  return `user:${userId}:${parts.join(':')}`;
}
```

### `lib/cache/cached-queries.ts`
```typescript
import { createClient } from '@/lib/supabase/server';
import { withCache, userCacheKey, cacheInvalidateByTag } from './redis-cache';

// Cache user settings
export async function getCachedUserSettings(userId: string) {
  return withCache(
    userCacheKey(userId, 'settings'),
    async () => {
      const supabase = createClient();
      const { data } = await supabase
        .from('user_settings')
        .select('*')
        .eq('user_id', userId)
        .single();
      return data;
    },
    { ttl: 300, tags: [`user:${userId}`] }
  );
}

// Cache integration status
export async function getCachedIntegrations(userId: string) {
  return withCache(
    userCacheKey(userId, 'integrations'),
    async () => {
      const supabase = createClient();
      const { data } = await supabase
        .from('integrations')
        .select('provider, status, metadata')
        .eq('user_id', userId);
      return data || [];
    },
    { ttl: 60, tags: [`user:${userId}`, 'integrations'] }
  );
}

// Cache dashboard stats
export async function getCachedDashboardStats(userId: string) {
  return withCache(
    userCacheKey(userId, 'dashboard-stats'),
    async () => {
      const supabase = createClient();
      
      const [orders, customers, pins] = await Promise.all([
        supabase
          .from('customer_orders')
          .select('total')
          .eq('user_id', userId)
          .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()),
        supabase
          .from('customers')
          .select('*', { count: 'exact', head: true })
          .eq('user_id', userId),
        supabase
          .from('pins')
          .select('*', { count: 'exact', head: true })
          .eq('user_id', userId)
          .eq('status', 'published'),
      ]);

      return {
        revenue: (orders.data || []).reduce((sum, o) => sum + Number(o.total), 0),
        orderCount: orders.data?.length || 0,
        customerCount: customers.count || 0,
        pinCount: pins.count || 0,
      };
    },
    { ttl: 300, tags: [`user:${userId}`, 'stats'] }
  );
}

// Cache top pins
export async function getCachedTopPins(userId: string, limit = 5) {
  return withCache(
    userCacheKey(userId, 'top-pins', String(limit)),
    async () => {
      const supabase = createClient();
      const { data } = await supabase
        .from('pin_analytics')
        .select(`
          pin_id,
          impressions,
          saves,
          clicks,
          pins(title, image_url)
        `)
        .eq('user_id', userId)
        .order('saves', { ascending: false })
        .limit(limit);
      return data || [];
    },
    { ttl: 600, tags: [`user:${userId}`, 'pins'] }
  );
}

// Invalidate all user cache
export async function invalidateUserCache(userId: string): Promise<void> {
  await cacheInvalidateByTag(`user:${userId}`);
}
```

- **Step Dependencies**: Step 24.3
- **User Instructions**: None (uses same Upstash Redis)

---

